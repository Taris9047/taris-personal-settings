#!/bin/sh

MYSHELL="$(ps --no-headers --pid $$ | awk '{print $5}')"

[ -d "${HOME}/.settings/bin" ] && export PATH="${HOME}/.settings/bin:${PATH}"

#
# -*- Do NOT EDIT THIS FILE DIRECTLY!! -*-
# This file is automatically generated by Orgmode from
#
# ./my_settings.org
#
# Refer this file to change or add/remove features. Changing this
# file alone will not apply your changes permanently!!
#

# [[ $- != *i* ]] && return
fd=0
if ! "$(command -v test)" -t "$fd"; then
    return
fi

check_symbol="\033[1;32m\u2713\033[0m"
right_arrow_symbol="\033[1;37m\u2192\033[0m"
line_delay=0.07

stringcontain() {
	[ -z "$1" ] || { [ -z "${2##*$1*}" ] && [ -n "$2" ]; }
}

if [ -x "$(command -v tmux)" ] && ! stringcontain 'screen' "$TERM" && ! stringcontain 'tmux' "$TERM" && [ -z "$TMUX" ] && [ -n "$SSH_CLIENT" ]; then
	printf '%b tmux has found!! Running it!\n' "${check_symbol}"
	tmux
	builtin exit
fi

# if [ -x "$(command -v tmux)" ] && stringcontain 'xterm' "$TERM"; then
#     builtin exit
# fi

alias tmuxkillall='tmux kill-server'

case $(echo $MYSHELL) in
*"bash")
	shopt -s autocd
	shopt -s cdspell
	shopt -s cmdhist
	shopt -s dotglob
	shopt -s histappend
	shopt -s expand_aliases
	shopt -s checkwinsize
	;;
*) ;;
esac

export TERM="xterm-256color"
export HISTCONTROL="ignoredups:erasedups"

[ -d "${HOME}/.settings" ] && cd "${HOME}/.settings" && git pull && cd -

export MYSETTINGSDIR="${HOME}/.config/my_settings"
[ ! -d "${MYSETTINGSDIR}" ] && mkdir -p "${MYSETTINGSDIR}"

export LS_MODE_SAVE="${MYSETTINGSDIR}/ls_mode"
if [ -f "${LS_MODE_SAVE}" ]; then
    ls_mode="$(cat "$LS_MODE_SAVE")"
    export LS_MODE="${ls_mode}"
else
    export LS_MODE='lsd'
    touch "${LS_MODE_SAVE}"
    echo 'lsd' >"${LS_MODE_SAVE}"
fi

export BATTHEMESAVE="${MYSETTINGSDIR}/bat_theme"
if [ ! -f "${BATTHEMESAVE}" ]; then
    touch "${BATTHEMESAVE}"
    echo "Dracula" >"${BATTHEMESAVE}"
fi

HBREW_PATH="${HOME}/.local"
if [ -d "${HBREW_PATH}" ]; then
    export HOMEBREW="${HBREW_PATH}"
    printf "%b HOMEBREW directory is %s\n" "${check_symbol}" "${HOMEBREW}"

    sleep "${line_delay}"
    export PATH="${HOMEBREW}/bin:${PATH}"
    export PATH="${HOMEBREW}/.opt/bin:${PATH}"
    [ ! -d "${HOMEBREW}" ] && mkdir -p "${HOMEBREW}"
    [ ! -d "${HOMEBREW}/bin" ] && mkdir -p "${HOMEBREW}/bin"
    [ ! -d "${HOMEBREW}/.opt" ] && mkdir -p "${HOMEBREW}/.opt"
fi

# Let's set up ls as lsd or exa (default is lsd as of now.)
set_ls_as_ls() {
    unalias ls ll lld l lt l. 2> /dev/null
    alias ls='ls -p -F -h --color=auto --show-control-chars'
    alias ll='ls -la'
    alias lld='du'
    alias l='ls -p -F -h --color=auto --show-control-chars'
    alias lt='tree'
    alias l.='ls -a | grep "^\."'
    echo 'ls' >"${LS_MODE_SAVE}"
}

set_exa_as_ls() {
    if [ -x "$(command -v exa)" ]; then
        sleep "${line_delay}"
        unalias ls ll lld l lt l. 2> /dev/null
        alias ls='exa -hF --color=always --group-directories-first'
        alias ll='exa -lahF --color=always --group-directories-first'
        alias lld='du'
        alias l='exa -hF --color=always --group-directories-first'
        alias lt='exa -aT --color=always --group-directories-first'
        alias l.='exa -a | egrep "^\."'
        echo 'exa' >"$LS_MODE_SAVE"
    else
        printf 'It seems exa has not yet installed!!\nUsing the good old ls\n'
        set_ls_as_ls
    fi

}

set_lsd_as_ls() {
    if [ -x "$(command -v lsd)" ]; then
        sleep "${line_delay}"
        unalias ls ll lld l lt l. 2> /dev/null
        alias ls='lsd -hF --color=always --group-dirs=first'
        alias ll='lsd -lahF --color=always --group-dirs=first'
        alias lld='du'
        alias l='lsd -hF --color=auto --group-dirs=first'
        alias lt='lsd -a --tree --color=fancy --group-dirs=first'
        alias l.='lsd -a | egrep "^\."'
        echo 'lsd' >"$LS_MODE_SAVE"
    else
        printf 'It seems lsd has not yet installed!!\nUsing the good old ls\n'
        set_ls_as_ls
    fi
}

set_ls() {
    if [ "$#" -eq 0 ]; then
        sleep 0
        # printf "%b Current ls mode is: %s\n" "${check_symbol}" "${LS_MODE}"
    else
        LS_MODE="$1"
    fi

    case "${LS_MODE}" in
    "lsd")
        printf "  %b Activating '%s' mode.\n" "${right_arrow_symbol}" "${LS_MODE}"
        set_lsd_as_ls
        ;;
    "exa")
        printf "  %b Activating '%s' mode.\n" "${right_arrow_symbol}" "${LS_MODE}"
        set_exa_as_ls
        ;;
    "ls")
        printf "  %b Activating '%s' mode.\n" "${right_arrow_symbol}" "${LS_MODE}"
        set_ls_as_ls
        ;;
    "*")
        printf "  %b Activating '%s' mode.\n" "${right_arrow_symbol}" "${LS_MODE}"
        printf "    Select one of: lsd, exa, ls\n"
        ;;
    esac
}

GOOGLE_DRIVE="${HOME}/.google-drive"
GOOGLE_PHOTOS="${HOME}/.google-photos"
ONE_DRIVE="${HOME}/.onedrive"

texlive_base_path="${HOME}/.texlive"

if [ -x "$(command -v nvim)" ]; then
    export EDITOR="nvim"
elif [ -x "$(command -v vim)" ] && [ ! -x "$(command -v nvim)" ]; then
    export EDITOR="vim"
else
    export EDITOR="vi"
fi



if [ -x "$(command -v gedit)" ]; then
    export EDITOR="gedit"
    export VISUAL="gedit"
fi

if [ -x "$(command -v xed)" ]; then
    export EDITOR="xed"
    export VISUAL="xed"
fi

if [ -x "$(command -v emacs)" ]; then
    export EDITOR="emacs"
    export VISUAL="emacs"
fi

if [ -n "$SSH_CLIENT" ] || [ -n "$SSH_TTY" ]; then
    export EDITOR="vi"
    export VISUAL="vi"
fi

case "${TERM}" in
  xterm*|rxvt*|Eterm*|aterm|kterm|gnome*|alacritty|st|konsole*)
    PROMPT_COMMAND='echo -ne "\033]0;${USER}@${HOSTNAME%%.*}:${PWD/#$HOME/\~}\007"'
        ;;
  screen*)
    PROMPT_COMMAND='echo -ne "\033_${USER}@${HOSTNAME%%.*}:${PWD/#$HOME/\~}\033\\"'
    ;;
esac

if [ -f "${HOME}/.Xresources" ] && [ -x "$(command -v xrdb)" ]; then
    printf '%b Reading in Xterm configurations!!\n' "${check_symbol}"
    xrdb -merge "${HOME}/.Xresources"
fi

if [ ! -z "$(grep -i 'Microsoft' /proc/version)" ]; then
    export DISPLAY=$(ip route|awk '/^default/{print $3}'):0.0
    printf '%b Setting up DISPLAY for WSL: %s\n' "${check_symbol}" "${DISPLAY}"
fi

if [ ! -x "$(command -v spark)" ]; then
	printf '%b Installing spark!!\n' "${check_symbol}"
	[ ! -d "$HOMEBREW/bin" ] && mkdir -pv "$HOMEBREW/bin"
	sh -c "curl https://raw.githubusercontent.com/holman/spark/master/spark -o $HOMEBREW/bin/spark" && "chmod +x $HOMEBREW/bin/spark" || true
    chmod +x "$HOMEBREW/bin/spark" || true
fi

if [ ! -x "$(command -v rclone)" ] && [ -z "$SSH_CLIENT" ]; then
    #printf '%b Installing RClone!!\n' "${check_symbol}"
    #echo; echo; curl 'https://rclone.org/install.sh' | sudo -H bash
    printf '%b rclone command not found, you can install it with install_rclone alias.\n' "${check_symbol}"
    alias install_rclone="curl \"https://rclone.org/install.sh\" | sudo -H bash"
fi

unalias rm mv cp grep egrep fgrep df rsync sudo free 2> /dev/null || true
alias rm='rm -i'
alias mv='mv -i'
alias cp='cp -i'
alias grep='grep --color=auto'
alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias df='df -h'
alias rsync='rsync -azvh --info=progress2'
alias sudo='sudo -H'
alias free='free -m'

function aptup () {
    if [ -x "$(command -v nala)" ]; then
        printf 'nala detected!! Using it!!\n'
        sudo nala update && sudo nala upgrade -y
        return 0
    fi

    if [ -x "$(command -v apt-get)" ]; then
        sudo apt-get -y update && sudo apt-get -y upgrade
    elif [ -x "$(command -v apt)" ]; then
        sudo apt -y update && sudo apt -y upgrade
    else
        printf 'ERROR: Cannot find apt or apt-get in the system.\n'
        return 1
    fi
    return 0
}

function aptin () {
    if [ -x "$(command -v nala)" ]; then
        printf 'nala detected!! Using it!!\n'
        aptup && sudo nala install -y "$@"
    else
        aptup && sudo apt-get -y install "$@"
    fi
}

function dnfup () {
    if [ -x "$(command -v dnf)" ]; then
        sudo dnf -y update
    else
        printf 'ERROR: Cannot find dnf in the system!! Maybe try with Yum?\n'
        return 1
    fi
    return 0
}

function dnfin () {
    dnfup && sudo dnf -y install "$@"
}

function yumup () {
    if [ -x "$(command -v yum)" ]; then
        sudo yum -y update
    else
        printf 'ERROR: Cannot find yum!\n'
        return 1
    fi
    return 0
}

function yumin () {
    yumup && yum -y install "$@"
}

function pacmansync () {
    if [ ! -z "$1" ] && [ -x "$(command -v pacman-mirrors)" ]; then
        sudo pacman-mirrors --continent
    fi
    if [ -x "$(command -v pacman)" ]; then
        sudo pacman -Syuu
    fi
    if [ -x "$(command -v pamac)" ]; then
        sudo pamac upgrade -a
    fi
}

function pacmanin () {
    if [ -x "$(command -v pamac)" ]; then
        sudo pamac upgrade -a && sudo pamac install "$@"
    else
        sudo pacman -Syuu "$@"
    fi
}

function flatpakup () {
    printf 'Updating Flatpak and its packages\n'
    flatpak upgrade -y
}

function snapup () {
    printf 'Updating Snap packages\n'
    sudo snap refresh
}

function universal_pkgman_up () {
    [ -x "$(command -v flatpak)" ] && flatpakup 2>&1
    [ -x "$(command -v snap)" ] && snapup 2>&1
}

function pkgup () {
    printf 'Updating the system with package manager!\n'
    [ -x "$(command -v apt-get)" ] && aptup 2>&1 && universal_pkgman_up 2>&1 && return 0
    [ -x "$(command -v dnf)" ] && dnfup 2>&1 && universal_pkgman_up 2>&1 && return 0
    [ -x "$(command -v yum)" ] && yumup 2>&1 && universal_pkgman_up 2>&1 && return 0
    [ -x "$(command -v pacman)" ] && pacmansync 2>&1 && universal_pkgman_up 2>&1 && return 0
}

function pkgin () {
    [ -x "$(command -v apt-get)" ] && aptin "$@" 2>&1 && return 0
    [ -x "$(command -v dnf)" ] && dnfin "$@" 2>&1 && return 0
    [ -x "$(command -v yum)" ] && yumin "$@" 2>&1 && return 0
    [ -x "$(command -v pacman)" ] && pacmanin "$@" 2>&1 && return 0
}

alias cd..='cd ..' # Just like MS-DOS
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'

alias psmem='ps auxf | sort -nr -k 4'
alias psmem10='ps auxf | sort -nr -k 4 | head -10'
alias pscpu='ps auxf | sort -nr -k 3'
alias pscpu10='ps auxf | sort -nr -k 3 | head -10'
alias gpg-check='gpg2 --keyserver-options auto-key-retrieve --verify'
alias gpg-retrieve='gpg2 --keyserver-options auto-key-retrieve --receive-keys'
alias battery_stat='upower -i "$( upower -e | grep BAT )"'

gitc() {
    git commit -a -m "\"${1}\""
    git push
}
gcatchup() {
    git fetch --all
    git reset --hard origin/master
    git pull
}
gtag() {
    git tag -a "\"${1}\""
}
alias gaddup='git add -u'
alias gaddall='git add .'
gitlog2w() {
    for day in $(seq 14 -1 0); do
        git log --before="${day} days" --after="$("$day"+1) days" --format=oneline | wc -l
    done | spark
}
gitlog8h() {
    for hour in $(seq 8 -1 0); do
        git log --before="${hour} hours" --after="$("$hour"+1) hours" --format=oneline | wc -l
    done | spark
}

alias tb='nc termbin.com 9999'

[ -x "$(command -v zsh)" ] && alias tozsh='sudo chsh "$USER" -s "$(command -v zsh)" && echo "Now log out."'
[ -x "$(command -v fish)" ] && alias tofish='sudo chsh "$USER" -s "$(command -v fish)" && echo "Now log out."'

if [ -x "$(command -v youtube-dl)" ]; then
    printf '%b youtube-dl found! setting up yta(ytv)-* commands.\n' "${check_symbol}"
    alias yta-help="echo 'yta-aac yta-best yta-flac yta-m4a yta-mp3 yta-opus yta-vorbis yta-wav ytv-best'"
    alias yta-aac="youtube-dl --extract-audio --audio-format aac "
    alias yta-best="youtube-dl --extract-audio --audio-format best "
    alias yta-flac="youtube-dl --extract-audio --audio-format flac "
    alias yta-m4a="youtube-dl --extract-audio --audio-format m4a "
    alias yta-mp3="youtube-dl --extract-audio --audio-format mp3 "
    alias yta-opus="youtube-dl --extract-audio --audio-format opus "
    alias yta-vorbis="youtube-dl --extract-audio --audio-format vorbis "
    alias yta-wav="youtube-dl --extract-audio --audio-format wav "
    alias ytv-best="youtube-dl -f bestvideo+bestaudio "
    sleep ${line_delay}
fi

if [ -x "$(command -v spark)" ] && [ -x "$(command -v lolcat)" ]; then
    alias clear='/usr/bin/clear; echo; seq 1 $(/usr/bin/tput cols) | sort -R | spark | lolcat; echo; echo'
elif [ -x "$(command -v spark)" ] && [ ! -x "$(command -v lolcat)" ]; then
    alias clear='/usr/bin/clear; echo; seq 1 $(/usr/bin/tput cols) | sort -R | spark; echo'
fi

[ -x "$(command -v uxterm)" ] && alias xterm='uxterm'
[ -x "$(command -v urxvt)" ] && alias rxvt='urxvt'

addpath() {
    case ":$PATH:" in
        *":$1:"* ) ;;
        * ) export PATH="$1:$PATH" ;;
    esac
}

ex() {
	if [ -z "$1" ]; then
		# display usage if no parameters given
		echo "Usage: extract <path/file_name>.<zip|rar|bz2|gz|tar|tbz2|tgz|Z|7z|xz|ex|tar.bz2|tar.gz|tar.xz>"
		echo "       extract <path/file_name_1.ext> [path/file_name_2.ext] [path/file_name_3.ext]"
	else
		for n in "$@"; do
			if [ -f "$n" ]; then
				case "$n" in
				*.cbt | *.tar.bz2 | *.tar.gz | *.tar.xz | *.tbz2 | *.tgz | *.txz | *.tar)
					tar xvf "$n"
					;;
				*.lzma) unlzma ./"$n" ;;
				*.bz2) bunzip2 ./"$n" ;;
				*.cbr | *.rar) unrar x -ad ./"$n" ;;
				*.gz) gunzip ./"$n" ;;
				*.cbz | *.epub | *.zip) unzip ./"$n" ;;
				*.z) uncompress ./"$n" ;;
				*.7z | *.arj | *.cab | *.cb7 | *.chm | *.deb | *.dmg | *.iso | *.lzh | *.msi | *.pkg | *.rpm | *.udf | *.wim | *.xar)
					7z x ./"$n"
					;;
				*.xz) unxz ./"$n" ;;
				*.exe) cabextract ./"$n" ;;
				*.cpio) cpio -id <./"$n" ;;
				*.cba | *.ace) unace x ./"$n" ;;
				*)
					echo "extract: '$n' - unknown archive method"
					return 1
					;;
				esac
			else
				echo "'$n' - file does not exist"
				return 1
			fi
		done
	fi

}

up () {
    local d=""
    local limit="$1"

    # Default to limit of 1
    ([ -z "$limit" ] || [ "$limit" -le 0 ]) && limit=1

    #for ((i=1;i<=limit;i++)); do
    #    d="../$d"
    #done
    j=0
    while [ "$j" -lt "$limit" ]; do
        d="../$d"
        j=$(( j+1 ))
    done

    # perform cd. Show error if cd fails
    if ! cd "$d"; then
        echo "Couldn't go up $limit dirs.";
    fi
}

delete_recursive ()
{
    echo "Querying files!!"
    echo "================================"
    if [ -x "$(command -v fd)" ]; then
        fd -IH -g "$1" -tf
    else
        find . -name "$1" -type f
    fi
    echo "================================"
    read -p "Do you wish to delete them? [yn]" yn
    while true; do
        case "$yn" in
        [Yy]* )
            if [ -x "$(command -v fd)" ]; then
            if [ -x "$(command -v rip)" ]; then
                fd -IH -g "$1" -tf -X rip
            else
                fd -IH -g "$1" -tf -X rm
            fi
            else
            find . -name "$1" -type f -delete
            fi
            echo "Deleted the files!!"
            ;;
        [Nn]* )
        echo "Not deleting!!"; break
        ;;
        * )
        echo "Please answer y or n."
        ;;
        esac
    done
}

open() {
for i in "$*"; do
    xdg-open "$i" >/dev/null 2>/dev/null
done
}

check_uptime() {
    echo "$(awk '{print $1}' /proc/uptime)"
}

if [ -x "$(command -v alacritty)" ]; then
    if [ -n "$(cat /proc/cpuinfo | grep 'hypervisor')" ]; then
        alias alacritty="MESA_GL_VERSION_OVERRIDE=3.3 LIBGL_ALWAYS_SOFTWARE=1 alacritty"
    fi
fi

SNAP_BIN="/snap/bin"
if [ -d "${SNAP_BIN}" ]; then
    printf '%b Snap executables have been found at %s\n' "${check_symbol}" "${SNAP_BIN}"
    addpath "${SNAP_BIN}"
fi

if [ -x "$(command -v broot)" ]; then
    printf '%b Broot found!\n' "${check_symbol}"
    alias br='broot -dhp'
    alias bs='broot --sizes'
fi

DEFAULT_JAVA_HOME=/opt/java
JAVA_HOME=''
if [ -x "$(command -v java)" ]; then
    export JAVA_HOME="$(echo "$(command -v java)" | rev | cut -c10- | rev )"
fi

# Prefer /opt/java instead of system installed java
if [ -x "$(command -v "$DEFAULT_JAVA_HOME/bin/java")" ]; then
    export JAVA_HOME="${DEFAULT_JAVA_HOME}"
fi

if [ -d "$JAVA_HOME" ]; then
    printf '%b Java (Possibly Oracle) found at %s\n' "${check_symbol}" "${JAVA_HOME}"
    sleep "${line_delay}"
    addpath "${JAVA_HOME}/bin"
    export JAVA_HOME="${JAVA_HOME}"
    export CLASSPATH="${JAVA_HOME}/lib"
else
    printf '%b Java was not found in the system!\n' "${check_symbol}"
    unset JAVA_HOME
fi

DEFAULT_M2_HOME=/opt/maven
M2_HOME=''
if [ -x "$(command -v mvn)" ]; then
    export M2_HOME="$(echo "$(command -v mvn)" | rev | cut -c10- | rev )"
fi

# Prefer /opt/java instead of system installed java
if [ -x "$(command -v "$DEFAULT_M2_HOME/bin/mvn")" ]; then
    export M2_HOME="${DEFAULT_M2_HOME}"
fi

if [ -d "$M2_HOME" ]; then
    printf '%b Apache Maven found at %s\n' "${check_symbol}" "${M2_HOME}"
    sleep "${line_delay}"
    addpath "${M2_HOME}/bin"
    export M2_HOME="${M2_HOME}"
    export CLASSPATH="${M2_HOME}/lib"
else
    printf '%b Apache Maven was not found in the system!\n' "${check_symbol}"
    unset M2_HOME
fi

JEDIT_PATH="${HOMEBREW}/.opt/jEdit/bin"
[ -x "$(command -v $JEDIT_PATH/jedit)" ] && export PATH="${JEDIT_PATH}:${PATH}"
[ -x "$(command -v "$HOMEBREW/bin/jedit")" ] && JEDIT_PATH="${HOMEBREW}/bin/jedit"
printf '%b jEdit found at %s\n' "${check_symbol}" "${JEDIT_PATH}"

# Emacs selection path: $HOMEBREW/bin/emacs > /snap/bin/emacs > system emacs such as ... /usr/bin/emacs
emacs_candidates=( "$HOMEBREW/bin/emacs" "$SNAP_BIN/emacs" "/usr/local/bin/emacs" "/usr/bin/emacs" )
for emacs_cand in "${emacs_candidates[@]}"
do
    if [ -x "${emacs_cand}" ]; then
        emacs_cmd="${emacs_cand}"
        emacsclient_cmd="$(dirname "${emacs_cand}")"/emacsclient
        break
    fi
done

if [ -x "$(command -v emacs)" ] && [ -x "$(command -v emacsclient)" ]; then
    unalias emc emt emacs emacsclient 2> /dev/null
    # Checking whether /etc/os-release exists... some old distros do not have os-release...
    if [ -f '/etc/os-release' ]; then
        if [ ! -z "$(cat /etc/os-release | grep ID | grep elementary)" ]; then
            alias emc="env XLIB_SKIP_ARGB_VISUALS=1 ${emacsclient_cmd} -c -a '$emacs_cmd' "
            alias emacs="env XLIB_SKIP_ARGB_VISUALS=1 ${emacs_cmd}"
            alias emt="${emacs_cmd} -nw"
        else
            alias emc="${emacsclient_cmd} -c -a '$emacs_cmd' "
            alias emacs="${emacs_cmd}"
            alias emt="${emacs_cmd} -nw"
        fi
    fi
fi

if [ -d "${HOME}/.cargo" ]; then
    printf '%b Cargo directory detected at %s\n' "${check_symbol}" "${HOME}/.cargo"
    sleep ${line_delay}
    . "${HOME}/.cargo/env"
fi

alias cargo-update='rustup update && cargo install $(cargo install --list | egrep '\''^[a-z0-9_-]+ v[0-9.]+:$'\'' | cut -f1 -d'\'' '\'')'

if [ -d "${HOMEBREW}/.opt/gcc-jit" ]; then
    printf '%b Gcc with libgccjit found in the system!\n' "${check_symbol}"
    addpath "${HOMEBREW}/.opt/gcc-jit/bin"
fi
if [ -d "${HOMEBREW}/.opt/gcc9" ]; then
    printf '%b Gcc9 found in the system!\n' "${check_symbol}"
    addpath "${HOMEBREW}/.opt/gcc9/bin"
fi
if [ -d "${HOMEBREW}/.opt/gcc8" ]; then
    printf '%b Gcc8 found in the system!\n' "${check_symbol}"
    addpath "${HOMEBREW}/.opt/gcc8/bin"
fi
if [ -d "${HOMEBREW}/.opt/gcc4" ]; then
    printf '%b Gcc4 found in the system!\n' "${check_symbol}"
    addpath "${HOMEBREW}/.opt/gcc4/bin"
fi

export GOROOT="${HOMEBREW}/.opt/go"
export GOPATH="${HOMEBREW}/.opt/go/bin"
if [ -d "$GOROOT" ]; then
    printf '%b Golang has been found at %s\n' "${check_symbol}" "${GROOT}"
    addpath "${GOPATH}/bin:${GOPATH}"
fi

JULIA_ROOT="${HOMEBREW}/.opt/julia"
JULIA_BIN="${JULIA_ROOT}/bin"
if [ -d "${JULIA_ROOT}" ] && [ -f "${JULIA_BIN}/julia" ]; then
    printf '%b Julia has been found at %s\n' "${check_symbol}" "${JULIA_ROOT}"
    addpath "${JULIA_BIN}"
fi

if [ -x "$(command -v vncserver)" ]; then
    echo "*** VNC server found! ***"
    echo " To start: vncstart"
    echo " To end: vnckill"
    echo ""
    alias vncstart="vncserver -localhost no -useold -geometry 1600x900 -depth 32"
    alias vnckill="vncserver -kill :1"
fi

ROOT_DIR="${HOMEBREW}/.opt/ROOT"
if [ -x "$(command -v $ROOT_DIR/bin/root)" ]; then
    printf '%b ROOT Found! Applying its shell env.\n' "${check_symbol}"
    alias thisroot="${ROOT_DIR}/bin/thisroot.sh"
fi

if [ -x "$(command -v vim)" ]; then
  printf "%b vim found! replacing stupid old vi!\n" "${check_symbol}"
  sleep "${line_delay}"
  unalias vi vim 2>/dev/null || true
  alias vi='vim'
fi

if [ -x "$(command -v nvim)" ]; then
	printf '%b Neovim found! replacing vim!\n' "${check_symbol}"
	sleep "${line_delay}"
	unalias vi vim 2>/dev/null || true
	alias vim="nvim"
	alias vi="nvim"
	if [ -x "$(command -v nvim-gtk)" ]; then
		unalias gvim 2>/dev/null || true
		alias gvim="nvim-gtk"
	fi
fi

texlive_year='current'
texlive_arch='x86_64-linux'
texlive_bin_dir="${texlive_base_path}/${texlive_year}/bin/${texlive_arch}/"
texlive_bin_dir_woyear="${texlive_base_path}/bin/${texlive_arch}/"

texlive_years=(2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030)

for yr in ${texlive_years[@]}; do
    if [ ! -d "$texlive_base_path/$texlive_year" ] && [ -d "$texlive_base_path/$yr" ]; then
        ln -sf "$texlive_base_path/$yr" "$texlive_base_path/current"
    fi
done

if [ -d "$texlive_bin_dir" ]; then
    printf '%b Texlive found at %s directory!!\n' "${check_symbol}" "$texlive_bin_dir"
    export PATH="$texlive_bin_dir:$PATH"
elif [ -d "$texlive_bin_dir_woyear" ]; then
    printf '%b Texlive found at %s directory!!\n' "${check_symbol}" "$texlive_bin_dir_woyear"
    export PATH="$texlive_bin_dir_woyear:$PATH"
fi

if [ -x "$(command -v $HOMEBREW/.opt/pypy/bin/pypy3)" ]; then
	printf "%b pypy3 found in ${HOMEBREW}/.opt/pypy/bin/pypy3!!\n" "${check_symbol}"
	sleep "${line_delay}"
	export PATH="${HOMEBREW}/.opt/pypy/bin:${PATH}"
fi

PYENV_DIR="${HOME}/.pyenv"
if [ -d "${PYENV_DIR}" ]; then
    printf '%b Pyenv found!! Extending environments\n' "${check_symbol}"
    export PYENV_ROOT="${PYENV_DIR}"
    export PATH="${PYENV_DIR}/bin:${PATH}"
    eval "$(pyenv init -)"
    eval "$(pyenv init --path)"
fi

if [ -d "${PYENV_DIR}" ]; then
    alias pyenvup="cd ${PYENV_DIR} && git pull && cd -"
    export PYTHON_CONFIGURE_OPTS="--enable-shared --enable-ipv6 --enable-unicode=ucs4 --with-threads --with-ensurepip=yes --enable-optimizations"
fi

RBENV_DIR="${HOME}/.rbenv"
if [ -d "${RBENV_DIR}" ]; then
    printf '%b Rbenv found!! Extending environments\n' "${check_symbol}"
    export RBENV_ROOT="${RBENV_DIR}"
    export PATH="${RBENV_DIR}/bin:${PATH}"
    eval "$(rbenv init - bash)"
fi

BPYTOP_PATH="${HOMEBREW}/bin/bpytop"
PIP3_PATH="${HOMEBREW}/bin/pip3"

if [ -x "$(command -v $HOME/.pyenv/shims/pip)" ]; then
    BPYTOP_PATH="${HOME}/.pyenv/shims/bpytop"
    PIP3_PATH="${HOME}/.pyenv/shims/pip"
fi

if [ -x "$(command -v $PIP3_PATH)" ] && [ -x "$(command -v $BPYTOP_PATH)" ]; then
    printf '%b Locally installed bpytop found!\n' "${check_symbol}"
    sleep ${line_delay}
    alias bpytop="${PIP3_PATH} install -U bpytop && ${BPYTOP_PATH}"
    alias htop="${BPYTOP_PATH}"
    alias top="${BPYTOP_PATH}"
fi

if [ -x "$(command -v n)" ]; then
    printf '%b n found!, Setting up N_PREFIX environment variable.\n' "${check_symbol}"
    sleep "${line_delay}"
    export N_PREFIX="$(command -v n | sed -E 's/\/bin\/n//')"
fi

iview64_path="${HOME}/.wine/drive_c/Program Files/IrfanView/i_view64.exe"
run_iview() {
	wine "${iview64_path}" "$(winepath --windows "$@")"
}
if [ -x "$(command -v wine)" ]; then
	if [ -f "${iview64_path}" ]; then
		printf '%b Irfanview found!!\n' "${check_symbol}"
		printf '  %b Usage: iview <files>\n' "${right_arrow_symbol}"
		alias iview=run_iview
		sleep ${line_delay}
	fi
fi

ltspice_path="${HOME}/.wine/drive_c/Program Files/LTC/LTspiceXVII/XVIIx64.exe"
run_ltspice ()
{
    wine "${ltspice_path}" "$(winepath --windows "$@")"
}
if [ -x "$(command -v wine)" ]; then
    if [ -f "${ltspice_path}" ]; then
        printf '%b LTSpice found!!\n' "${check_symbol}"
        printf '  %b Usage: ltspice \n' "${right_arrow_symbol}"
        alias ltspice=run_ltspice
        sleep ${line_delay}
    fi
fi

if [ -f "${HOME}/.emacs.d/bin/doom" ]; then
    printf '%b Doomemacs found! Adding to path!\n' "${check_symbol}"
    addpath "${HOME}/.emacs.d/bin"
    # Also, setting up some aliases
    alias doomsync='~/.emacs.d/bin/doom sync'
    alias doomdoctor='~/.emacs.d/bin/doom doctor'
    alias doomupgrade='~/.emacs.d/bin/doom upgrade'
    alias doompurge='~/.emacs.d/bin/doom purge'
fi

if [ -x "$(command -v /usr/lib/cuda/bin/nvcc)" ]; then
    printf '%b Package manager CUDA found! Doing some env stuff for it!\n' "${check_symbol}"
    export LD_LIBRARY_PATH="/usr/lib/cuda/lib64:${LD_LIBRARY_PATH}"
    export PATH="${PATH}:/usr/lib/cuda/bin"
fi

if [ -d "/usr/local/cuda-6.5" ]; then
    printf '%b CUDA 6.5 found! Doing some env stuff for it.\n' "${check_symbol}"
    export LD_LIBRARY_PATH="/usr/local/cuda-6.5/lib64:${LD_LIBRARY_PATH}"
    export PATH="${PATH}:/usr/local/cuda-6.5/bin"
fi

if [ -x "$(command -v jq)" ]; then
    printf '%b jq found, we can use geolocation alias as: geoloc\n' "${check_symbol}"
    alias geoloc="curl -s http://ip-api.com/json/$(curl -s https://ipinfo.io/ip) | jq '.lat, .lon, .city, .country'"
fi

BROWSER="$(command -v firefox)"
JUPYTER_DIR="${HOME}/.jupyter"
JUPYTER_CONFIG="${JUPYTER_DIR}/jupyter_notebook_config.py"
if grep -q "snap" <<< "${BROWSER}"; then
    printf '%b System browser seems to be snap version. Generating config file to avert the problem...\n' "${check_symbol}"
    mkdir -p "${JUPYTER_DIR}"
    if [ ! -f "${JUPYTER_CONFIG}" ]; then
        touch "${JUPYTER_CONFIG}"
    fi
    echo 'c.NotebookApp.use_redirect_file = False' >> "${JUPYTER_CONFIG}"
fi

. "${HOME}/.settings/dotfiles/Synopsys.sh"

. "${HOME}/.settings/dotfiles/Xilinx.sh"

if [ -x "$(command -v dust)" ]; then
    printf '%b dust found! Using it instead of du!\n' "${check_symbol}"
    alias du='dust -r'
else
    alias du='du -skh | sort -r'
fi

if [ -x "$(command -v bat)" ]; then
    printf '%b bat found! using it instead of cat\n' "${check_symbol}"
    sleep "${line_delay}"
    bat_theme="$(cat $BATTHEMESAVE)"
    alias cat='bat --theme="$bat_theme"'
fi

set_bat_theme() {
    echo "$1" >"$BATTHEMESAVE"
    bat_theme="$(cat $BATTHEMESAVE)"
    alias cat='bat --theme="$bat_theme"'
}

bat_theme_light() {
    echo 'Solarized (light)' >"$BATTHEMESAVE"
    bat_theme="$(cat $BATTHEMESAVE)"
    alias cat='bat --theme="$bat_theme"'
}
bat_theme_dark() {
    echo "Dracula" >"$BATTHEMESAVE"
    bat_theme="$(cat $BATTHEMESAVE)"
    alias cat='bat --theme="$bat_theme"'
}

trash_location="$HOME/.local/share/Trash/files/"
if [ -x "$(command -v rip)" ]; then
    printf '%b rip, rm-improved found!\n  %b Setting up graveyard at %s\n' "${check_symbol}" "${right_arrow_symbol}" "${trash_location}"
    sleep "${line_delay}"
    alias rip="rip --graveyard $trash_location"
fi

if [ -x "$(command -v zoxide)" ]; then
    printf '%b zoxide found! activating it!\n' "${check_symbol}"
    sleep "${line_delay}"
    case "$(echo $MYSHELL)" in
        *"bash") eval "$(zoxide init bash)"; alias cd='z' ;;
        *"zsh") eval "$(zoxide init zsh)" ;;
        *) eval "$(zoxide init posix --hook prompt)" ;;
    esac
fi

if [ -x "$(command -v starship)" ]; then
    printf '%b Starship shell extension found! Let''''s start it!\n' "${check_symbol}"
    sleep "${line_delay}"

    case "$(echo $0)" in
        *"bash")
            printf '  %b Running it as bash\n' "${right_arrow_symbol}"
            eval "$(starship init bash)"
            ;;
        *"zsh")
            printf '  %b Running it as zsh\n' "${right_arrow_symbol}"
            eval "$(starship init zsh)"
            ;;
        *) ;;
    esac
fi

clear
if [ -x "$(command -v figlet)" ]; then
    if [ -x "$(command -v lolcat)" ]; then
        figlet -f future -w "$(/usr/bin/tput cols)" "$(uname -n)" | "$(command -v lolcat)"
    else
        figlet -f future -w "$(/usr/bin/tput cols)" "$(uname -n)"
    fi
fi

([ -x "$(command -v neofetch)" ] && [ "$(printf '%.0f' "$(check_uptime)")" -lt 2400 ]) && neofetch

path_sanitized=$(printf "%s" "$PATH" | awk -v RS=':' '!a[$1]++ { if (NR > 1) printf RS; printf $1 }')
export PATH="${path_sanitized}"

set_ls

VPN_PATH="/opt/cisco/secureclient/bin/vpn"
[ -x "${VPN_PATH}" ] && \
    alias ucsc_vpn="${HOME}/.settings/bin/vpn_connect_ucsc.sh"
