#!/usr/bin/env bash

#
# -*- Do NOT EDIT THIS FILE DIRECTLY!! -*-
# This file is automatically generated by Orgmode from
#
# ./my_settings.org
#
# Refer this file to change or add/remove features. Changing this
# file alone will not apply your changes permanently!!
#

export TERM="xterm-256color"
export HISTCONTROL=ignoredups:erasedups

check_symbol="\033[1;32m\u2713\033[0m"
right_arrow_symbol="\033[1;37m\u2192\033[0m"
line_delay=0.12

export MYSETTINGSDIR="$HOME/.config/my_settings"
if [ ! -d "$MYSETTINGSDIR" ]; then
    mkdir -p "$MYSETTINGSDIR"
fi

export LS_MODE_SAVE="$MYSETTINGSDIR/ls_mode"
if [ -f "$LS_MODE_SAVE" ]; then
	export LS_MODE="$(cat "$LS_MODE_SAVE")"
else
	export LS_MODE='lsd'
	touch "$LS_MODE_SAVE"
	echo 'lsd' >"$LS_MODE_SAVE"
fi

export BATTHEMESAVE="$MYSETTINGSDIR/bat_theme"
export BATTHEME="Dracula"
if [ -f "$BATTHTMESAVE" ]; then
	export BATTHEME="$(cat "$BATTHEMESAVE")"
else
	touch $BATTHEMESAVE
	echo $BATTHEME >"$BATTHEMESAVE"
fi

HBREW_PATH="$HOME/.local"
if [ -d "${HBREW_PATH}" ]; then
	export HOMEBREW="${HBREW_PATH}"
	printf "${check_symbol} HOMEBREW directory is ${HOMEBREW}\n"
	sleep ${line_delay}
	export PATH="$HOMEBREW/bin:$PATH"
	export PATH="$HOMEBREW/.opt/bin:$PATH"
	if [ ! -d "${HOMEBREW}" ]; then
		mkdir -p "${HOMEBREW}"
	fi
	if [ ! -d "${HOMEBREW}/bin" ]; then
		mkdir -p "${HOMEBREW}/bin"
	fi
	if [ ! -d "${HOMEBREW}/.opt" ]; then
		mkdir -p "${HOMEBREW}/.opt"
	fi
fi

# Let's set up ls as lsd or exa (default is lsd as of now.)
set_ls_as_ls() {
	alias ls='ls -p -F -h --color=auto --show-control-chars'
	alias ll='ls -la'
	alias lld='du'
	alias l='ls -p -F -h --color=auto --show-control-chars'
	alias lt='tree'
	alias l.='ls -a | grep "^\."'
	echo 'ls' >"$LS_MODE_SAVE"
}

set_exa_as_ls() {
	if [ -x "$(command -v exa)" ]; then
		sleep ${line_delay}
		alias ls='exa -hF --color=always --group-directories-first'
		alias ll='exa -lahF --color=always --group-directories-first'
		alias lld='du'
		alias l='exa -hF --color=always --group-directories-first'
		alias lt='exa -aT --color=always --group-directories-first'
		alias l.='exa -a | egrep "^\."'
		echo 'exa' >"$LS_MODE_SAVE"
	fi
}

set_lsd_as_ls() {
	if [ -x "$(command -v lsd)" ]; then
		sleep ${line_delay}
		alias ls='lsd -hF --color=always --group-dirs=first'
		alias ll='lsd -lahF --color=always --group-dirs=first'
		alias lld='du'
		alias l='lsd -hF --color=auto --group-dirs=first'
		alias lt='lsd -a --tree --color=fancy --group-dirs=first'
		alias l.='lsd -a | egrep "^\."'
		echo 'lsd' >"$LS_MODE_SAVE"
	fi
}

set_ls() {
	if [ $# -eq 0 ]; then
		printf "${check_symbol} Current ls mode is: ${LS_MODE}\n"
	else
		LS_MODE="$1"
	fi

	case "$LS_MODE" in
	"lsd")
		printf "  ${right_arrow_symbol} Activating '${LS_MODE}' mode.\n"
		set_lsd_as_ls
		;;
	"exa")
		printf "  ${right_arrow_symbol} Activating '${LS_MODE}' mode.\n"
		set_exa_as_ls
		;;
	"ls")
		printf "  ${right_arrow_symbol} Activating '${LS_MODE}' mode.\n"
		set_ls_as_ls
		;;
	"*")
		printf "  ${right_arrow_symbol} ${LS_MODE} is not available!\n"
		printf "    Select one of: lsd, exa, ls\n"
		;;
	esac
}
set_ls

GOOGLE_DRIVE="$HOME/.google-drive"
ONE_DRIVE="$HOME/.onedrive"

texlive_base_path="$HOME/.texlive"

if [ -x "$(command -v nvim)" ]; then
	export EDITOR="nvim"
elif [ -x "$(command -v vim)" ] && [ ! -x "$(command -v nvim)" ]; then
	export EDITOR="vim"
else
	export EDITOR="vi"
fi

if [ -x "$(command -v subl)" ]; then
	export VISUAL="subl"
else
	export VISUAL="xdg-open"
fi

case ${TERM} in
  xterm*|rxvt*|Eterm*|aterm|kterm|gnome*|alacritty|st|konsole*)
    PROMPT_COMMAND='echo -ne "\033]0;${USER}@${HOSTNAME%%.*}:${PWD/#$HOME/\~}\007"'
        ;;
  screen*)
    PROMPT_COMMAND='echo -ne "\033_${USER}@${HOSTNAME%%.*}:${PWD/#$HOME/\~}\033\\"'
    ;;
esac

if [ ! -x "$(command -v spark)" ]; then
	printf "$check_symbol Installing spark!!\n"
	if [ ! -d "$HOMEBREW/bin" ]; then
		mkdir -pv "$HOMEBREW/bin"
	fi
	sh -c "curl https://raw.githubusercontent.com/holman/spark/master/spark -o $HOMEBREW/bin/spark && chmod +x $HOMEBREW/bin/spark" || true
fi

if [ ! -x "$(command -v rclone)" ]; then
  printf "$check_symbol Installing RClone!!\n"
  curl https://rclone.org/install.sh | sudo -H bash
fi

alias rm='rm -i'
alias mv='mv -i'
alias cp='cp -i'
alias grep='grep --color=auto'
alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias df='df -h'
alias rsync='rsync -azvh --info=progress2'
alias sudo='sudo -H'
alias free='free -m'

alias aptup='sudo apt-get -y update && sudo apt-get -y upgrade'
alias aptin='sudo apt-get -y update && sudo apt-get -y upgrade && sudo apt-get install'
alias dnfup='sudo dnf -y update'
alias dnfin='sudo dnf -y install'
alias pmyy='sudo pacman -Syyu'
alias pmin='sudo pacman -Syyu'

alias cd..='cd ..' # Just like MS-DOS
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'

alias psmem='ps auxf | sort -nr -k 4'
alias psmem10='ps auxf | sort -nr -k 4 | head -10'
alias pscpu='ps auxf | sort -nr -k 3'
alias pscpu10='ps auxf | sort -nr -k 3 | head -10'
alias gpg-check="gpg2 --keyserver-options auto-key-retrieve --verify"
alias gpg-retrieve="gpg2 --keyserver-options auto-key-retrieve --receive-keys"
alias battery_stat="upower -i `upower -e | grep 'BAT'`"

gitc() {
	git commit -a -m "\"${1}\""
	git push
}
gcatchup() {
	git fetch --all
	git reset --hard origin/master
	git pull
}
gtag() {
	git tag -a "\"${1}\""
}
alias gaddup='git add -u'
alias gaddall='git add .'
gitlog2w() {
	for day in $(seq 14 -1 0); do
		git log --before="${day} days" --after="$($day+1) days" --format=oneline | wc -l
	done | spark
}
gitlog8h() {
	for hour in $(seq 8 -1 0); do
		git log --before="${hour} hours" --after="$($hour+1) hours" --format=oneline | wc -l
	done | spark
}

alias tb="nc termbin.com 9999"

if [ -x "$(command -v zsh)" ]; then
    alias tozsh="sudo chsh $USER -s $(command -v zsh) && echo 'Now log out.'"
fi
if [ -x "$(command -v fish)" ]; then
    alias tofish="sudo chsh $USER -s $(command -v fish) && echo 'Now log out.'"
fi

if [ -x $(command -v youtube-dl) ]; then
  printf "${check_symbol} youtube-dl found! setting up yta(ytv)-* commands.\n"
  alias yta-help="echo 'yta-aac yta-best yta-flac yta-m4a yta-mp3 yta-opus yta-vorbis yta-wav ytv-best'"
  alias yta-aac="youtube-dl --extract-audio --audio-format aac "
  alias yta-best="youtube-dl --extract-audio --audio-format best "
  alias yta-flac="youtube-dl --extract-audio --audio-format flac "
  alias yta-m4a="youtube-dl --extract-audio --audio-format m4a "
  alias yta-mp3="youtube-dl --extract-audio --audio-format mp3 "
  alias yta-opus="youtube-dl --extract-audio --audio-format opus "
  alias yta-vorbis="youtube-dl --extract-audio --audio-format vorbis "
  alias yta-wav="youtube-dl --extract-audio --audio-format wav "
  alias ytv-best="youtube-dl -f bestvideo+bestaudio "
  sleep ${line_delay}
fi

if [ -x "$(command -v spark)" ] && [ -x "$(command -v lolcat)" ]; then
  alias clear='clear; echo; seq 1 $(tput cols) | sort -R | spark | lolcat; echo; echo'
elif [ -x "$(command -v spark)" ] && [ ! -x "$(command -v lolcat)" ]; then
  alias clear='clear; echo; seq 1 $(tput cols) | sort -R | spark; echo'
fi

addpath() {
    case ":$PATH:" in
        *":$1:"* ) ;;
        * ) export PATH="$1:$PATH" ;;
    esac
}

ex ()
{
  if [ -f $1 ] ; then
    case $1 in
      *.tar.bz2)   tar xjf $1   ;;
      *.tar.gz)    tar xzf $1   ;;
      *.bz2)       bunzip2 $1   ;;
      *.rar)       unrar x $1   ;;
      *.gz)        gunzip $1    ;;
      *.tar)       tar xf $1    ;;
      *.tbz2)      tar xjf $1   ;;
      *.tgz)       tar xzf $1   ;;
      *.zip)       unzip $1     ;;
      *.Z)         uncompress $1;;
      *.7z)        7z x $1      ;;
      *.deb)       ar x $1      ;;
      *.tar.xz)    tar xf $1    ;;
      *.tar.zst)   unzstd $1    ;;
      *)           echo "'$1' cannot be extracted via ex()" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

up () {
  local d=""
  local limit="$1"

  # Default to limit of 1
  if [ -z "$limit" ] || [ "$limit" -le 0 ]; then
    limit=1
  fi

  for ((i=1;i<=limit;i++)); do
    d="../$d"
  done

  # perform cd. Show error if cd fails
  if ! cd "$d"; then
    echo "Couldn't go up $limit dirs.";
  fi
}

delete_recursive ()
{
  echo "Querying files!!"
  echo "================================"
  if [ -x "$(command -v fd)" ]; then
    fd -IH -g "$1" -tf
  else
    find . -name "$1" -type f
  fi
  echo "================================"
  read -p "Do you wish to delete them? [yn]" yn
  while true; do
    case $yn in
      [Yy]* )
        if [ -x "$(command -v fd)" ]; then
          if [ -x "$(command -v rip)"]; then
            fd -IH -g "$1" -tf -X rip
          else
            fd -IH -g "$1" -tf -X rm
          fi
        else
          find . -name "$1" -type f -delete
        fi
        echo "Deleted the files!!"
        ;;
    [Nn]* )
      echo "Not deleting!!"; break
      ;;
    * )
      echo "Please answer y or n."
      ;;
    esac
  done
}

open() {
	for i in $*; do
		setsid nohup xdg-open $i >/dev/null 2>/dev/null
	done
}

check_uptime() {
  echo "$(awk '{print $1}' /proc/uptime)"
}

if [ -x "$(command -v broot)" ]; then
	printf "${check_symbol} Broot found!\n"
	alias br='broot -dhp'
	alias bs='broot --sizes'
fi

JAVA_HOME=/opt/java
if [ -d "$JAVA_HOME" ]; then
  printf "${check_symbol} Java (Possibly Oracle) found at $JAVA_HOME\n"
  sleep ${line_delay}
  addpath "${JAVA_HOME}/bin"
  export CLASSPATH=${JAVA_HOME}/lib
fi

if [ ! -z "$(cat /etc/os-release | grep ID | grep elementary)" ]; then
	alias emacs='XLIB_SKIP_ARGB_VISUALS=1 emacs'
	alias emacsclient='XLIB_SKIP_ARGB_VISUALS=1 emacsclient'
fi

if [ ! -z "$(ps -A | grep emacs)" ]; then
	alias emacs='emacsclient -c'
	alias emacst='emacsclient -t'
fi

if [ -d $HOME/.cargo ]; then
  printf "${check_symbol} Cargo directory detected at $HOME/.cargo\n"
  sleep ${line_delay}
  source $HOME/.cargo/env
fi

if [ -d $HOMEBREW/.opt/gcc-jit ]; then
  printf "${check_symbol} Gcc with libgccjit found in the system!\n"
  addpath "$HOMEBREW/.opt/gcc-jit/bin"
fi
if [ -d $HOMEBREW/.opt/gcc9 ]; then
  printf "${check_symbol} Gcc9 found in the system!\n"
  addpath "$HOMEBREW/.opt/gcc9/bin"
fi
if [ -d $HOMEBREW/.opt/gcc8 ]; then
  printf "${check_symbol} Gcc8 found in the system!\n"
  addpath "$HOMEBREW/.opt/gcc8/bin"
fi
if [ -d $HOMEBREW/.opt/gcc4 ]; then
  printf "${check_symbol} Gcc4 found in the system!\n"
  addpath "$HOMEBREW/.opt/gcc4/bin"
fi

export GOROOT=$HOMEBREW/.opt/go
export GOPATH=$HOMEBREW/.opt/go/bin
if [ -d $GOROOT ]; then
  printf "${check_symbol} Golang has been found at $GOROOT\n"
  addpath "$GOPATH/bin:$GOPATH"
fi

SNAP_BIN=/snap/bin
if [ -d "$SNAP_BIN" ]; then
	printf "${check_symbol} Snap executables have been found at $SNAP_BIN\n"
	addpath "$SNAP_BIN"
fi

if [ -x "$(command -v vncserver)" ]; then
  echo "*** VNC server found! ***"
  echo " To start: vncstart"
  echo " To end: vnckill"
  echo ""
  alias vncstart="vncserver -localhost no -useold -geometry 1200x800 -depth 32"
  alias vnckill="vncserver -kill :1"
fi

if [ -x "$(command -v $HOMEBREW/bin/pip3)" ]; then
  if [ -x "$(command -v $HOMEBREW/bin/bpytop)" ]; then
    printf "${check_symbol} Locally installed bpytop found!\n"
    sleep ${line_delay}
    alias bpytop="$HOMEBREW/bin/pip3 install -U bpytop && bpytop"
    alias htop=bpytop
    alias top=bpytop
  fi
fi

ROOT_DIR=$HOMEBREW/.opt/ROOT
if [ -x "$(command -v $ROOT_DIR/bin/root)" ]; then
  printf "${check_symbol} ROOT Found! Applying its shell env.\n"
  alias thisroot="$ROOT_DIR/bin/thisroot.sh"
fi

if [ -x "$(command -v nvim)" ]; then
  printf "${check_symbol} Neovim found! replacing vim!\n"
  sleep ${line_delay}
  alias vim="nvim"
  alias vi="nvim"
fi

texlive_year="2020"
texlive_arch=x86_64-linux
texlive_bin_dir=$texlive_base_path/$texlive_year/bin/$texlive_arch/
texlive_bin_dir_woyear=$texlive_base_path/bin/$texlive_arch/
if [ -d $texlive_bin_dir ]; then
  printf "${check_symbol} Texlive found at $texlive_bin_dir directory!!\n"
  export PATH=$texlive_bin_dir:$PATH
elif [ -d $texlive_bin_dir_woyear ]; then
  printf "${check_symbol} Texlive found at $texlive_bin_dir_woyear directory!!\n"
  export PATH=$texlive_bin_dir_woyear:$PATH
fi

if [ -x "$(command -v $HOMEBREW/.opt/pypy/bin/pypy3)" ]; then
  printf "${check_symbol} pypy3 found in $HOMEBREW/.opt/pypy/bin/pypy3!!\n"
  sleep ${line_delay}
  export PATH=$HOMEBREW/.opt/pypy/bin:$PATH
fi

if [ -x "$(command -v n)" ]; then
  printf "${check_symbol} n found!, Setting up N_PREFIX environment variable.\n"
  sleep ${line_delay}
  export N_PREFIX=$(command -v n | sed -E 's/\/bin\/n//')
fi

iview64_path=$HOME/.wine/drive_c/Program\ Files/IrfanView/i_view64.exe
run_iview ()
{
  wine "$iview64_path" `winepath --windows $@`
}
if [ -x "$(command -v wine)" ]; then
  if [ -f "$iview64_path" ]; then
    printf "${check_symbol} Irfanview found!!\n"
    printf "  ${right_arrow_symbol} Usage: iview <files>\n"
    alias iview=run_iview
    sleep ${line_delay}
  fi
fi

if [ -x "$HOME/.emacs.d/bin/doom" ] && [ -d "$HOME/.doom.d" ]; then
  printf "${check_symbol} Doomemacs found! Adding to path!\n"
  addpath "$HOME/.emacs.d/bin"
fi

if [ -d "/usr/local/cuda-6.5" ]; then
  printf "${check_symbol} CUDA 6.5 found! Doing some env stuff for it.\n"
  export LD_LIBRARY_PATH="/usr/local/cuda-6.5/lib64":$LD_LIBRARY_PATH
  export PATH=$PATH:"/usr/local/cuda-6.5/bin"
fi

if [ -x "$(command -v jq)" ]; then
	echo "${check_symbol} jq found, we can use geolocation alias as: geoloc"
	alias geoloc="curl -s https://ipvigilante.com/$(curl -s https://ipinfo.io/ip) | jq '.data.latitude, .data.longitude, .data.city_name, .data.country_name'"
fi

if [ -x "$(command -v dust)" ]; then
	printf "${check_symbol} dust found! Using it instead of du!\n"
	alias du='dust -r'
else
	alias du='du -skh | sort -r'
fi

if [ -x "$(command -v bat)" ]; then
	printf "${check_symbol} bat found! using it instead of cat\n"
	sleep ${line_delay}
	alias cat='bat --theme="$BATTHEME"'
fi

set_bat_theme() {
	echo "$1" >"$BATTHEMESAVE"
	export BATTHEME="$1"
}

bat_theme_light() {
	echo "Solarized (light)" >"$BATTHEMESAVE"
	export BATTHEME="Solarized (light)"
}
bat_theme_dark() {
	echo "Dracula" >"$BATTHEMESAVE"
	export BATTHEME="Dracula"
}

trash_location="$HOME/.local/share/Trash/files/"
if [ -x "$(command -v rip)" ]; then
  printf "${check_symbol} rip, rm-improved found!\n  ${right_arrow_symbol} Setting up graveyard at $trash_location\n"
  sleep ${line_delay}
  alias rip="rip --graveyard $trash_location"
fi

if [ -x "$(command -v zoxide)" ]; then
  printf "${check_symbol} zoxide found! activating it!\n"
  sleep ${line_delay}
  if [[ "$(echo $0)" == *bash ]]; then
    eval "$(zoxide init bash)"
  elif [[ "$(echo $0)" == *zsh ]]; then
    eval "$(zoxide init zsh)"
  else
    eval "$(zoxide init posix --hook prompt)"
  fi
  alias cd='z'
fi

if [ -x "$(command -v rclone)" ]; then

	if [ ! -d $GOOGLE_DRIVE ]; then
		printf "${check_symbol} Google drive mount point not found! making one..\n"
		mkdir -pv $GOOGLE_DRIVE
	fi

	if grep -qs $GOOGLE_DRIVE /proc/mounts; then
		printf "${check_symbol} Google Drive already mounted at $GOOGLE_DRIVE\n"
		sleep ${line_delay}
	elif [ ! -f "$HOME/.config/rclone/rclone.conf" ]; then
		printf "${check_symbol} RClone was for Google drive not set up yet!\n"
	else
		if [ ! -z "$(cat $HOME/.config/rclone/rclone.conf | grep "\[google-drive\]")" ]; then
			printf "${check_symbol} Mounting Google Drive to $GOOGLE_DRIVE\n"
			rclone mount google-drive: $GOOGLE_DRIVE &
			sleep 2

		fi
	fi
fi

if [ -x "$(command -v rclone)" ]; then

	if [ ! -d $GOOGLE_DRIVE ]; then
		printf "${check_symbol} Google drive mount point not found! making one..\n"
		mkdir -pv $GOOGLE_DRIVE
	fi

	if grep -qs $GOOGLE_DRIVE /proc/mounts; then
		printf "${check_symbol} Google Drive already mounted at $GOOGLE_DRIVE\n"
		sleep ${line_delay}
	elif [ ! -f "$HOME/.config/rclone/rclone.conf" ]; then
		printf "${check_symbol} RClone was for Google drive not set up yet!\n"
	else
		if [ ! -z "$(cat $HOME/.config/rclone/rclone.conf | grep "\[google-drive\]")" ]; then
			printf "${check_symbol} Mounting Google Drive to $GOOGLE_DRIVE\n"
			rclone mount google-drive: $GOOGLE_DRIVE &
			sleep 2

		fi
	fi
fi

if [ -x "$(command -v rclone)" ]; then
	if grep -qs $ONE_DRIVE /proc/mounts; then
		printf "${check_symbol} MS One Drive already mounted at $ONE_DRIVE\n"
		sleep ${line_delay}
	elif [ ! -f "$HOME/.config/rclone/rclone.conf" ]; then
		printf "${check_symbol} RClone for Onedrive was not set up yet!\n"
	else
		if [ ! -z "$(cat $HOME/.config/rclone/rclone.conf | grep "\[onedrive\]")" ]; then
			printf "${check_symbol} Mounting MS One Drive to $ONE_DRIVE\n"
			rclone mount --vfs-cache-mode writes onedrive: $ONE_DRIVE &
			sleep 2
		fi
	fi
fi

if [ -x "$(command -v starship)" ]; then
  printf "${check_symbol} Starship shell extension found! Let's start it!\n"
  sleep ${line_delay}
  printf "  ${right_arrow_symbol} Running it as zsh"
  eval "$(starship init zsh)"
fi

clear

if [ -x "$(command -v neofetch)" ] && [ $(printf '%.0f' $(check_uptime)) -lt 2400 ]; then
	neofetch
fi

export PATH=$(printf "%s" "$PATH" | awk -v RS=':' '!a[$1]++ { if (NR > 1) printf RS; printf $1 }')
