#+TITLE: Taris' Doom Emacs Config
#+AUTHOR: Taylor Shin
#+STARTUP: showeverything
#+PROPERTY: header-args :tangle-mode

* My Shell Settings
Let's use Orgmode to construct and manage shell script files more effectively! Automatic tangling will populate my_settings_<shell_name> files automatically.

My main shell is of course Bash but I'm trying to expand out into other shells such as Zsh and Fish. Especially for Zsh, [[https://apple.stackexchange.com/questions/361870/what-are-the-practical-differences-between-bash-and-zsh][this guide on StackExchange]] was especially helpful.

* Table of Contents :toc:
- [[#my-shell-settings][My Shell Settings]]
- [[#exports][Exports]]
  - [[#she-bang-preambles][She-bang preambles]]
  - [[#some-warning-messages][Some Warning messages]]
  - [[#terminal-type-and-history-control][Terminal type and history control]]
  - [[#some-decorative-stuffs][Some decorative stuffs]]
  - [[#autocompletion-color][Autocompletion color]]
  - [[#manpage-reader][Manpage reader]]
  - [[#ls-mode-initial-set-up][ls mode initial set up]]
  - [[#homebrew-directory-set][Homebrew directory set]]
  - [[#ls-mode-set---we-will-install-exa-and-lsd-later][ls mode set - We will install exa and lsd later.]]
  - [[#cloud-directories][Cloud directories]]
  - [[#texlive-home-directory-set][Texlive home directory set]]
  - [[#default-cligui-editor-set][Default CLI/GUI editor set]]
  - [[#change-terminal-titles][Change terminal titles]]
- [[#hot-spot-installation][Hot Spot Installation]]
  - [[#spark][Spark]]
  - [[#rclone][RClone]]
- [[#command-line-aliases][Command line aliases]]
  - [[#binutils---linux][Binutils - Linux]]
  - [[#package-manager-shortcuts][Package Manager shortcuts]]
  - [[#quickly-exit-from-a-directory][Quickly exit from a directory]]
  - [[#system-utilities-shortcuts][System utilities shortcuts]]
  - [[#git-shortcuts][Git shortcuts]]
  - [[#termbin][Termbin]]
  - [[#switching-shells][Switching shells]]
  - [[#youtube-dl-shortcuts][youtube-dl shortcuts]]
  - [[#clear-screen][Clear screen]]
- [[#basic-functions-for-everyday-use][Basic Functions for everyday use]]
  - [[#prepending-system-path-variable][Prepending system PATH variable.]]
  - [[#extract-archive][Extract archive]]
  - [[#navigate-upwards][Navigate upwards.]]
  - [[#recursively-delete-files][Recursively delete files]]
  - [[#universal-open-function][Universal 'open' function]]
  - [[#check-uptime][Check uptime]]
- [[#settings-for-custom-installed-programs][Settings for Custom installed programs!]]
  - [[#broot][Broot]]
  - [[#java-runtime-environment-or-java-development-kit][Java Runtime Environment (or Java Development Kit)]]
  - [[#emacs-situation-on-elementary-os-5][EMACS situation on elementary OS 5]]
  - [[#emacs-as-service-alias][Emacs as service alias]]
  - [[#rust-cargo-actually][Rust (Cargo, actually.)]]
  - [[#homebrewed-gcc][Homebrewed GCC]]
  - [[#golang][Golang]]
  - [[#snapd-stuff][Snapd stuff]]
  - [[#vnc-setup][VNC setup]]
  - [[#bpytop---top-htop-and-bashtop-replacement-by-python3][Bpytop - top, htop, and bashtop replacement by Python3]]
  - [[#root][ROOT]]
  - [[#neovim][Neovim]]
  - [[#texlive][Texlive]]
  - [[#pypy---homebrewed-pypy3][PyPy - Homebrewed pypy3]]
  - [[#n---homebrewed-nodejss-update-tool][n - Homebrewed Node.JS's update tool]]
  - [[#irfanview---what-yeah-wine][IrfanView - What? yeah, wine!]]
  - [[#doomemacs-doom-and-evil][Doomemacs! DOOM! and EVIL!]]
  - [[#cuda-for-nvidia-96009400m][Cuda for NVIDIA 9600/9400m]]
  - [[#geolocation][Geolocation]]
- [[#rust-replacements][Rust replacements]]
  - [[#du-dust---du-replacement][Du-dust - du replacement]]
  - [[#bat---cat-replacement][Bat - cat replacement]]
  - [[#rip---rm-improved][Rip - rm-improved]]
  - [[#zoxide---z-replacement][Zoxide - z replacement]]
- [[#mount-clouds][Mount Clouds]]
  - [[#google-drive][Google Drive]]
  - [[#onedrive][Onedrive]]
- [[#shell-extension][Shell extension]]
  - [[#starship][Starship]]
- [[#final-start-up][Final start-up]]
  - [[#clear-screen-1][Clear screen]]
  - [[#run-neofetch][Run Neofetch]]
  - [[#clean-up-path][Clean up path]]

* Exports
Fundamental variables to start with.

** She-bang preambles
*** Bash
#+begin_src shell :tangle my_settings_bash
#!/usr/bin/env bash
#+end_src
*** Zsh
#+begin_src shell :tangle my_settings_zsh
#!/usr/bin/env zsh
#+end_src
*** Fish
#+begin_src fish :tangle my_settings_fish
#!/usr/bin/env fish
set fish_greeting
#+end_src

** Some Warning messages
*** Bash
#+NAME: do_not_edit_info
#+begin_src shell :tangle my_settings_bash
#
# -*- Do NOT EDIT THIS FILE DIRECTLY!! -*-
# This file is automatically generated by Orgmode from
#
# ./my_settings.org
#
# Refer this file to change or add/remove features. Changing this
# file alone will not apply your changes permanently!!
#
#+end_src
*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<do_not_edit_info>>
#+end_src
*** Fish
#+begin_src fish :tangle my_settings_fish :noweb yes
<<do_not_edit_info>>
#+end_src

** Terminal type and history control
*** Bash
#+NAME: term_type_hist
#+begin_src shell :tangle my_settings_bash
export TERM="xterm-256color"
export HISTCONTROL=ignoredups:erasedups
#+end_src
*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<term_type_hist>>
#+end_src
*** Fish
#+begin_src fish :tangle my_settings_fish
set TERM "xterm-256color"
#+end_src

** Some decorative stuffs

*** Bash
#+NAME: env_var_decor
#+begin_src shell :tangle my_settings_bash
check_symbol="\033[1;32m\u2713\033[0m"
right_arrow_symbol="\033[1;37m\u2192\033[0m"
line_delay=0.12
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<env_var_decor>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
set check_symbol "\033[1;32m\u2713\033[0m"
set right_arrow_symbol "\033[1;37m\u2192\033[0m"
set line_delay 0.12
#+end_src

** Autocompletion color
*** Fish
#+begin_src fish :tangle my_settings_fish
set fish_color_normal brcyan
set fish_color_autosuggestion '#7d7d7d'
set fish_color_command brcyan
set fish_color_error '#ff6c6b'
set fish_color_param brcyan
#+end_src

** Manpage reader
*** Fish
#+begin_src fish :tangle my_settings_fish
if type -q bat
    set -x MANPAGER "sh -c 'col -bx | bat -l man -p'"
else if type -q vim and not type -q nvim
    set -x MANPAGER '/bin/bash -c "vim -MRn -c \"set buftype=nofile showtabline=0 ft=man ts=8 nomod nolist norelativenumber nonu noma\" -c \"normal L\" -c \"nmap q :qa<CR>\"</dev/tty <(col -b)"'
else if type -q nvim
    set -x MANPAGER "nvim -c 'set ft=man' -"
end
#+end_src

** ls mode initial set up
*** Bash
#+begin_src shell :tangle my_settings_bash
export LS_MODE='lsd'
#+end_src
*** Zsh
#+begin_src shell :tangle my_settings_zsh
export LS_MODE='lsd'
#+end_src
*** Fish
#+begin_src fish :tangle my_settings_fish
set LS_MODE 'lsd'
#+end_src

** Homebrew directory set

Custom compiled tools and libraries will be residing in this directory.

*** Bash
#+NAME: env_var_homebrew
#+begin_src shell :tangle my_settings_bash
HBREW_PATH="$HOME/.local"
if [ -d "${HBREW_PATH}" ]; then
	export HOMEBREW="${HBREW_PATH}"
	printf "${check_symbol} HOMEBREW directory is ${HOMEBREW}\n"
	sleep ${line_delay}
	export PATH="$HOMEBREW/bin:$PATH"
	export PATH="$HOMEBREW/.opt/bin:$PATH"
	if [ ! -d "${HOMEBREW}" ]; then
		mkdir -p "${HOMEBREW}"
	fi
	if [ ! -d "${HOMEBREW}/bin" ]; then
		mkdir -p "${HOMEBREW}/bin"
	fi
	if [ ! -d "${HOMEBREW}/.opt" ]; then
		mkdir -p "${HOMEBREW}/.opt"
	fi
fi
#+end_src

#+RESULTS: env_var_homebrew
: HOMEBREW directory is /home/taris/.local

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<env_var_homebrew>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
set HBREW_PATH "$HOME/.local"
if test -d $HBREW_PATH
   set -U HOMEBREW $HBREW_PATH
end
printf "$check_symbol HOMEBREW directory is $HOMEBREW\n"
sleep $line_delay
set fish_user_paths $HOMEBREW/bin $fish_user_paths
#+end_src

** ls mode set - We will install exa and lsd later.

*** Bash
#+NAME: env_ls_mode
#+begin_src shell :tangle my_settings_bash
# Let's set up ls as lsd or exa (default is lsd as of now.)
set_ls_as_ls() {
	alias ls='ls -p -F -h --color=auto --show-control-chars'
	alias ll='ls -la'
	alias lld='du'
	alias l='ls -p -F -h --color=auto --show-control-chars'
	alias lt='tree'
	alias l.='ls -a | grep "^\."'
}

set_exa_as_ls() {
	if [ -x "$(command -v exa)" ]; then
		sleep ${line_delay}
		alias ls='exa -hF --color=always --group-directories-first'
		alias ll='exa -lahF --color=always --group-directories-first'
		alias lld='du'
		alias l='exa -hF --color=always --group-directories-first'
		alias lt='exa -aT --color=always --group-directories-first'
		alias l.='exa -a | egrep "^\."'
	fi
}

set_lsd_as_ls() {
	if [ -x "$(command -v lsd)" ]; then
		sleep ${line_delay}
		alias ls='lsd -hF --color=always --group-dirs=first'
		alias ll='lsd -lahF --color=always --group-dirs=first'
		alias lld='du'
		alias l='lsd -hF --color=auto --group-dirs=first'
		alias lt='lsd -a --tree --color=fancy --group-dirs=first'
		alias l.='lsd -a | egrep "^\."'
	fi
}

set_ls() {
	if [ $# -eq 0 ]; then
		printf "${check_symbol} Current ls mode is: ${LS_MODE}\n"
	else
		LS_MODE="$1"
	fi

	case "$LS_MODE" in
	"lsd")
		printf "  ${right_arrow_symbol} Activating '${LS_MODE}' mode.\n"
		set_lsd_as_ls
		;;
	"exa")
		printf "  ${right_arrow_symbol} Activating '${LS_MODE}' mode.\n"
		set_exa_as_ls
		;;
	"ls")
		printf "  ${right_arrow_symbol} Activating '${LS_MODE}' mode.\n"
		set_ls_as_ls
		;;
	*)
		printf "  ${right_arrow_symbol} ${LS_MODE} is not available!\n"
		printf "    Select one of: lsd, exa, ls\n"
		;;
	esac
}
set_ls
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<env_ls_mode>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
# Let's set up ls as lsd or exa (default is lsd as of now.)
function set_ls_as_ls
    alias ls='ls -p -F -h --color=auto --show-control-chars'
    alias ll='ls -la'
    alias lld='du'
    alias l='ls -p -F -h --color=auto --show-control-chars'
    alias lt='tree'
    alias l.='ls -a | grep "^\."'
end

function set_exa_as_ls
    if type -q "exa"
        sleep $line_delay
        alias ls='exa -hF --color=always --group-directories-first'
        alias ll='exa -lahF --color=always --group-directories-first'
        alias lld='du'
        alias l='exa -hF --color=always --group-directories-first'
        alias lt='exa -aT --color=always --group-directories-first'
        alias l.='exa -a | egrep "^\."'
    end
end

function set_lsd_as_ls
    if type -q "lsd"
        sleep $line_delay
        alias ls='lsd -hF --color=always --group-dirs=first'
        alias ll='lsd -lahF --color=always --group-dirs=first'
        alias lld='du'
        alias l='lsd -hF --color=auto --group-dirs=first'
        alias lt='lsd -a --tree --color=fancy --group-dirs=first'
        alias l.='lsd -a | egrep "^\."'
    end
end

function set_ls
    if not count $argv >/dev/null
        printf "$check_symbol Current ls mode is: $LS_MODE\n"
    else
        set LS_MODE "$1"
    end

    switch "$LS_MODE"
        case "lsd"
            printf "  $right_arrow_symbol Activating '$LS_MODE' mode.\n"
            set_lsd_as_ls

        case "exa"
            printf "  $right_arrow_symbol Activating '$LS_MODE' mode.\n"
            set_exa_as_ls

        case "ls"
            printf "  $right_arrow_symbol Activating '$LS_MODE' mode.\n"
            set_ls_as_ls

        case "*"
            printf "  $right_arrow_symbol $LS_MODE is not available!\n"
            printf "    Select one of: lsd, exa, ls\n"
    end
end
set_ls
#+end_src

** Cloud directories
[[https://rclone.org/][RCLONE]] is a great tool for cloud service access. I'm using Google Drive and Microsoft's Onedrive. We can set up a remote drive access with RCLONE! These lines aren't actually installing or setting up the cloud services. But defines their mountpoints.

*** Bash
#+NAME: env_var_rclone
#+begin_src shell :tangle my_settings_bash
GOOGLE_DRIVE="$HOME/.google-drive"
ONE_DRIVE="$HOME/.onedrive"
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<env_var_rclone>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
set GOOGLE_DRIVE "$HOME/.google-drive"
set ONE_DRIVE "$HOME/.onedrive"
#+end_src

** Texlive home directory set

*** Bash
#+NAME: env_var_texlive
#+begin_src shell :tangle my_settings_bash
texlive_base_path="$HOME/.texlive"
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<env_var_texlive>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
set texlive_base_path "$HOME/.texlive"
#+end_src

** Default CLI/GUI editor set
Prioritizes Neovim first. But use VIM. VI is the last resort. I doubt any sane distribution manager would drop VI from default installation.

For a GUI editor, the situation differs. We can rely on 'xdg-open' in most cases for known mimetypes. But some flies, such as files withtout known extension, are not supported. So, we might need to find some 'fallback' editor.. such as Emacs? The default is [[https://www.sublimetext.com/][Sublime Text]], of course!

*** Bash
#+NAME: cli_gui_edit_set
#+begin_src shell :tangle my_settings_bash
if [ -x "$(command -v nvim)" ]; then
	export EDITOR="nvim"
elif [ -x "$(command -v vim)" ] && [ ! -x "$(command -v nvim)" ]; then
	export EDITOR="vim"
else
	export EDITOR="vi"
fi

if [ -x "$(command -v subl)" ]; then
	export VISUAL="subl"
else
	export VISUAL="xdg-open"
fi
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<cli_gui_edit_set>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
if type -q nvim
    set EDITOR "nvim"
else if type -q vim and not type -q nvim
    set EDITOR "vim"
else
    set EDITOR "vi"
end

if type -q subl
    set VISUAL "subl"
else
    set VISUAL "xdg-open"
end
#+end_src

** Change terminal titles
*** Bash
#+NAME: term_titles
#+begin_src shell :tangle my_settings_bash
case ${TERM} in
  xterm*|rxvt*|Eterm*|aterm|kterm|gnome*|alacritty|st|konsole*)
    PROMPT_COMMAND='echo -ne "\033]0;${USER}@${HOSTNAME%%.*}:${PWD/#$HOME/\~}\007"'
        ;;
  screen*)
    PROMPT_COMMAND='echo -ne "\033_${USER}@${HOSTNAME%%.*}:${PWD/#$HOME/\~}\033\\"'
    ;;
esac
#+end_src
*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<term_titles>>
#+end_src
*** Fish
#+begin_src fish :tangle my_settings_fish

#+end_src

* Hot Spot Installation
** Spark
*** Bash
#+NAME: inst_spark
#+begin_src shell :tangle my_settings_bash
if [ ! -x "$(command -v spark)" ]; then
	printf "$check_symbol Installing spark!!\n"
	if [ ! -d "$HOMEBREW/bin" ]; then
		mkdir -pv "$HOMEBREW/bin"
	fi
	sh -c "curl https://raw.githubusercontent.com/holman/spark/master/spark -o $HOMEBREW/bin/spark && chmod +x $HOMEBREW/bin/spark" || true
fi
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<inst_spark>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
if not type -q spark
    printf "$check_symbol Installing spark!!\n"
    printf "  $right_arrow_symbol Type in your password if you feel it's stuck!!\n"
    if not test -d "$HOMEBREW/bin"
        mkdir -pv "$HOMEBREW/bin"
    end
    sh -c "curl https://raw.githubusercontent.com/holman/spark/master/spark -o $HOMEBREW/bin/spark
    chmod +x $HOMEBREW/bin/spark"
    or true
end
#+end_src

** RClone
*** Bash
#+NAME: inst_rclone
#+begin_src shell :tangle my_settings_bash
if [ ! -x "$(command -v rclone)" ]; then
  printf "$check_symbol Installing RClone!!\n"
  curl https://rclone.org/install.sh | sudo -H bash
fi
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<inst_rclone>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
if not type -q rclone
    printf "$check_symbol Installing RClone!!\n"
    printf "  $right_arrow_symbol Type in your password if you feel it's halted!!\n"
    curl https://rclone.org/install.sh | sudo -H bash
end
#+end_src

* Command line aliases

Some basic aliases for linux binutils and other tools. OS X uses BSD based binutils has different options and acts a little bit differently and will be updated when I get an actually working Apple machine.

** Binutils - Linux
*** Bash
#+NAME: alias_binutils
#+begin_src shell :tangle my_settings_bash
alias rm='rm -i'
alias mv='mv -i'
alias cp='cp -i'
alias grep='grep --color=auto'
alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias df='df -h'
alias rsync='rsync -azvh --info=progress2'
alias sudo='sudo -H'
alias free='free -m'
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<alias_binutils>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish :noweb yes
<<alias_binutils>>
#+end_src

** Package Manager shortcuts
*** Bash
#+NAME: alias_pkg_managers
#+begin_src shell :tangle my_settings_bash
alias aptup='sudo apt-get -y update && sudo apt-get -y upgrade'
alias aptin='sudo apt-get -y update && sudo apt-get -y upgrade && sudo apt-get install'
alias dnfup='sudo dnf -y update'
alias dnfin='sudo dnf -y install'
alias pmyy='sudo pacman -Syyu'
alias pmin='sudo pacman -Syyu'
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<alias_pkg_managers>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish :noweb yes
alias aptup='sudo apt-get -y update; sudo apt-get -y upgrade'
alias aptin='sudo apt-get -y update; sudo apt-get -y upgrade; sudo apt-get install'
alias dnfup='sudo dnf -y update'
alias dnfin='sudo dnf -y install'
alias pmyy='sudo pacman -Syyu'
alias pmin='sudo pacman -Syyu'
#+end_src

** Quickly exit from a directory

*** Bash
#+NAME: alias_cdupup
#+begin_src shell :tangle my_settings_bash
alias cd..='cd ..' # Just like MS-DOS
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<alias_cdupup>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish :noweb yes
<<alias_cdupup>>
#+end_src

** System utilities shortcuts

*** Bash
#+NAME: alias_sysutils
#+begin_src shell :tangle my_settings_bash
alias psmem='ps auxf | sort -nr -k 4'
alias psmem10='ps auxf | sort -nr -k 4 | head -10'
alias pscpu='ps auxf | sort -nr -k 3'
alias pscpu10='ps auxf | sort -nr -k 3 | head -10'
alias gpg-check="gpg2 --keyserver-options auto-key-retrieve --verify"
alias gpg-retrieve="gpg2 --keyserver-options auto-key-retrieve --receive-keys"
alias battery_stat="upower -i `upower -e | grep 'BAT'`"
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<alias_sysutils>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish :noweb yes
<<alias_sysutils>>
#+end_src

** Git shortcuts

*** Bash
#+NAME: alias_git
#+begin_src shell :tangle my_settings_bash
gitc() {
	git commit -a -m "\"${1}\""
	git push
}
gcatchup() {
	git fetch --all
	git reset --hard origin/master
	git pull
}
gtag() {
	git tag -a "\"${1}\""
}
alias gaddup='git add -u'
alias gaddall='git add .'
gitlog2w() {
	for day in $(seq 14 -1 0); do
		git log --before="${day} days" --after="$($day+1) days" --format=oneline | wc -l
	done | spark
}
gitlog8h() {
	for hour in $(seq 8 -1 0); do
		git log --before="${hour} hours" --after="$($hour+1) hours" --format=oneline | wc -l
	done | spark
}
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<alias_git>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish :noweb yes
function gitc
    git commit -a -m "\"$argv[1]\""
    git push
end
function gcatchup
    git fetch --all
    git reset --hard origin/master
    git pull
end
function gtag
    git tag -a "\"$argv[1]\""
end
alias gaddup='git add -u'
alias gaddall='git add .'
function gitlog2w
    for day in (seq 14 -1 0)
        git log --before="$day days" --after="($day+1) days" --format=oneline | wc -l
        done | spark
    end
end
function gitlog8h
    for hour in (seq 8 -1 0)
        git log --before="$hour hours" --after="($hour+1) hours" --format=oneline | wc -l
        done | spark
    end
end
#+end_src

** Termbin
*** Bash
#+NAME: alias_termbin
#+begin_src shell :tangle my_settings_bash
alias tb="nc termbin.com 9999"
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<alias_termbin>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish :noweb yes
<<alias_termbin>>
#+end_src

** Switching shells
*** Bash
#+begin_src shell :tangle my_settings_bash
if [ -x "$(command -v zsh)" ]; then
    alias tozsh="sudo chsh $USER -s $(command -v zsh) && echo 'Now log out.'"
fi
if [ -x "$(command -v fish)" ]; then
    alias tofish="sudo chsh $USER -s $(command -v fish) && echo 'Now log out.'"
fi
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh
alias tobash="sudo chsh $USER -s $(command -v bash) && echo 'Now log out.'"
if [ -x "$(command -v fish)" ]; then
    alias tofish="sudo chsh $USER -s $(command -v fish) && echo 'Now log out.'"
fi
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
alias tobash="sudo chsh $USER -s (command -v bash); echo 'Now log out'"
if type -q zsh
    alias tozsh="sudo chsh $USER -s (command -v zsh); echo 'Now log out'"
end
#+end_src

** youtube-dl shortcuts
*** Bash
#+NAME: alias_youtube-dl
#+begin_src shell :tangle my_settings_bash
if [ -x $(command -v youtube-dl) ]; then
  printf "${check_symbol} youtube-dl found! setting up yta(ytv)-* commands.\n"
  alias yta-help="echo 'yta-aac yta-best yta-flac yta-m4a yta-mp3 yta-opus yta-vorbis yta-wav ytv-best'"
  alias yta-aac="youtube-dl --extract-audio --audio-format aac "
  alias yta-best="youtube-dl --extract-audio --audio-format best "
  alias yta-flac="youtube-dl --extract-audio --audio-format flac "
  alias yta-m4a="youtube-dl --extract-audio --audio-format m4a "
  alias yta-mp3="youtube-dl --extract-audio --audio-format mp3 "
  alias yta-opus="youtube-dl --extract-audio --audio-format opus "
  alias yta-vorbis="youtube-dl --extract-audio --audio-format vorbis "
  alias yta-wav="youtube-dl --extract-audio --audio-format wav "
  alias ytv-best="youtube-dl -f bestvideo+bestaudio "
  sleep ${line_delay}
fi
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<alias_youtube-dl>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
if type -q youtube-dl
    printf "$check_symbol youtube-dl found! setting up yta(ytv)-* commands.\n"
    alias yta-help="echo 'yta-aac yta-best yta-flac yta-m4a yta-mp3 yta-opus yta-vorbis yta-wav ytv-best'"
    alias yta-aac="youtube-dl --extract-audio --audio-format aac "
    alias yta-best="youtube-dl --extract-audio --audio-format best "
    alias yta-flac="youtube-dl --extract-audio --audio-format flac "
    alias yta-m4a="youtube-dl --extract-audio --audio-format m4a "
    alias yta-mp3="youtube-dl --extract-audio --audio-format mp3 "
    alias yta-opus="youtube-dl --extract-audio --audio-format opus "
    alias yta-vorbis="youtube-dl --extract-audio --audio-format vorbis "
    alias yta-wav="youtube-dl --extract-audio --audio-format wav "
    alias ytv-best="youtube-dl -f bestvideo+bestaudio "
    sleep $line_delay
end
#+end_src

** Clear screen
*** Bash
#+NAME: alias_clear
#+begin_src shell :tangle my_settings_bash
if [ -x "$(command -v spark)" ] && [ -x "$(command -v lolcat)" ]; then
  alias clear='clear; echo; seq 1 $(tput cols) | sort -R | spark | lolcat; echo; echo'
elif [ -x "$(command -v spark)" ] && [ ! -x "$(command -v lolcat)" ]; then
  alias clear='clear; echo; seq 1 $(tput cols) | sort -R | spark; echo'
fi
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<alias_clear>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
if type -q spark and type -q lolcat
    alias clear='clear; echo; echo; seq 1 (tput cols) | sort -R | spark | lolcat; echo; echo' # Coloured
else if type -q spark and not type -q lolcat
    alias clear='clear; echo; echo; seq 1 (tput cols) | sort -R | spark | echo; echo' # Non-Coloured end clear
end
#+end_src

* Basic Functions for everyday use
** Prepending system PATH variable.
Apparently, there are much better ways to handle this kind of job and many newer shell versions will provide some kind of macro or internal functions to do this. But I would rather stay safe.

*** Bash
#+NAME: func_addpath
#+begin_src shell :tangle my_settings_bash
addpath() {
    case ":$PATH:" in
        *":$1:"* ) ;;
        * ) export PATH="$1:$PATH" ;;
    esac
}
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<func_addpath>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
function addpath
    switch "$PATH"
        case "\*":$1:"\*"
            pass
        case "*"
            set fish_user_paths "$1" $fish_user_paths
    end
end
#+end_src

** Extract archive
Originally copied from Manjaro Linux. Just =ex <archive_file>= to extract any archive.

*** Bash
#+NAME: func_ex
#+begin_src shell :tangle my_settings_bash
ex ()
{
  if [ -f $1 ] ; then
    case $1 in
      *.tar.bz2)   tar xjf $1   ;;
      *.tar.gz)    tar xzf $1   ;;
      *.bz2)       bunzip2 $1   ;;
      *.rar)       unrar x $1   ;;
      *.gz)        gunzip $1    ;;
      *.tar)       tar xf $1    ;;
      *.tbz2)      tar xjf $1   ;;
      *.tgz)       tar xzf $1   ;;
      *.zip)       unzip $1     ;;
      *.Z)         uncompress $1;;
      *.7z)        7z x $1      ;;
      *.deb)       ar x $1      ;;
      *.tar.xz)    tar xf $1    ;;
      *.tar.zst)   unzstd $1    ;;
      *)           echo "'$1' cannot be extracted via ex()" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<func_ex>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
function ex
    if test -f $argv[1]
        switch $argv[1]
            case '*.tar.bz2'
                tar xjf $argv[1]
            case '*.tar.gz'
                tar xzf $argv[1]
            case '*.bz2'
                bunzip2 $argv[1]
            case '*.rar'
                unrar x $argv[1]
            case '*.gz'
                gunzip $argv[1]
            case '*.tar'
                tar xf $argv[1]
            case '*.tbz2'
                tar xjf $argv[1]
            case '*.tgz'
                tar xzf $argv[1]
            case '*.zip'
                unzip $argv[1]
            case '*.Z'
                uncompress $argv[1]
            case '*.7z'
                7z x $argv[1]
            case '*.deb'
                ar x $argv[1]
            case '*.tar.xz'
                tar xf $argv[1]
            case '*.tar.zst'
                unzstd $argv[1]
            case '*'
                echo "$argv[1] cannot be extracted via ex() yet."
        end
    else
        echo "$argv[1] is not a valid file!"
    end
end
#+end_src
** Navigate upwards.
Simple, =up <num_stage(?)_to_navigate_up>= to navigate upwards.
*** Bash
#+NAME: func_up
#+begin_src shell :tangle my_settings_bash
up () {
  local d=""
  local limit="$1"

  # Default to limit of 1
  if [ -z "$limit" ] || [ "$limit" -le 0 ]; then
    limit=1
  fi

  for ((i=1;i<=limit;i++)); do
    d="../$d"
  done

  # perform cd. Show error if cd fails
  if ! cd "$d"; then
    echo "Couldn't go up $limit dirs.";
  fi
}
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<func_up>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
function up
    set d ""
    set limit "$argv[1]"

    if test -z "$limit" -o "$limit" -le 0
        set limit 1
    end

    for i in (seq 0 "$limit")
        set d "../$d"
    end

    if ! cd "$d"
        echo "Couldn't go up $limit dirs."
    end
end
#+end_src

** Recursively delete files
*** Bash
#+NAME: func_delete_recursive
#+begin_src shell :tangle my_settings_bash
delete_recursive ()
{
  echo "Querying files!!"
  echo "================================"
  if [ -x "$(command -v fd)" ]; then
    fd -IH -g "$1" -tf
  else
    find . -name "$1" -type f
  fi
  echo "================================"
  read -p "Do you wish to delete them? [yn]" yn
  while true; do
    case $yn in
      [Yy]* )
        if [ -x "$(command -v fd)" ]; then
          if [ -x "$(command -v rip)"]; then
            fd -IH -g "$1" -tf -X rip
          else
            fd -IH -g "$1" -tf -X rm
          fi
        else
          find . -name "$1" -type f -delete
        fi
        echo "Deleted the files!!"
        ;;
    [Nn]* )
      echo "Not deleting!!"; break
      ;;
    * )
      echo "Please answer y or n."
      ;;
    esac
  done
}
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes 
<<func_delete_recursive>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
# To be implemented!!
#+end_src

** Universal 'open' function
Not fully implemented yet. It detects Xorg desktop's MIME association but not really versatile.

*** Bash
#+NAME: func_open
#+begin_src shell :tangle my_settings_bash
open() {
	for i in $*; do
		setsid nohup xdg-open $i >/dev/null 2>/dev/null
	done
}
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<func_open>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish :noweb yes
function open
    for i in $argv
        setsid nohup xdg-open $i > /dev/null 2> /dev/null
    end
end
#+end_src

** Check uptime
*** Bash
#+NAME: func_uptime
#+begin_src shell :tangle my_settings_bash
check_uptime() {
  echo "$(awk '{print $1}' /proc/uptime)"
}
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<func_uptime>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
function check_uptime
    echo (awk '{print $1}' /proc/uptime)
end
#+end_src

* Settings for Custom installed programs!
** Broot
*** Bash
#+NAME: prog_broot
#+begin_src shell :tangle my_settings_bash
if [ -x "$(command -v broot)" ]; then
	printf "${check_symbol} Broot found!\n"
	alias br='broot -dhp'
	alias bs='broot --sizes'
fi
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<prog_broot>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
if type -q broot
   alias br='broot -dhp'
   alias br='broot --sizes'
end
#+end_src

** Java Runtime Environment (or Java Development Kit)
*** Bash
#+NAME: prog_java
#+begin_src shell :tangle my_settings_bash
JAVA_HOME=/opt/java
if [ -d "$JAVA_HOME" ]; then
  printf "${check_symbol} Java (Possibly Oracle) found at $JAVA_HOME\n"
  sleep ${line_delay}
  addpath "${JAVA_HOME}/bin"
  export CLASSPATH=${JAVA_HOME}/lib
fi
#+end_src
*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<prog_java>>
#+end_src
*** Fish
#+begin_src fish :tangle my_settings_fish
set JAVA_HOME /opt/java
if test -d $JAVA_HOME
    printf "$check_symbol Java (Possibley Oracle) found at $JAVA_HOME\n"
    sleep $line_delay
    addpath "$JAVA_HOME/bin"
    set CLASSPATH=$JAVA_HOME/lib
end
#+end_src

** EMACS situation on elementary OS 5
There is a gtk bug that hampers running emacs on elementary OS's GUI environment. We have a walkaround here.
*** Bash
#+NAME: prog_emacs_elemOS
#+begin_src shell :tangle my_settings_bash
if [ ! -z "$(cat /etc/os-release | grep ID | grep elementary)" ]; then
	alias emacs='XLIB_SKIP_ARGB_VISUALS=1 emacs'
	alias emacsclient='XLIB_SKIP_ARGB_VISUALS=1 emacsclient'
fi
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<prog_emacs_elemOS>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
if test -z (cat /etc/os-release | grep 'ID' | grep 'elementary')
    alias emacs='XLIB_SKIP_ARGB_VISUALS=1 emacs'
    alias emacsclient='XLIB_SKIP_ARGB_VISUALS=1 emacsclient'
end
#+end_src

** Emacs as service alias
*** Bash
#+NAME: prog_emacs_service
#+begin_src shell :tangle my_settings_bash
if [ ! -z "$(ps -A | grep emacs)" ]; then
	alias emacs='emacsclient -c'
	alias emacst='emacsclient -t'
fi
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<prog_emacs_service>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
if not test -z "(ps -A | grep emacs)"
    alias emacs='emacsclient -c'
    alias emacst='emacsclient -t'
end
#+end_src

** Rust (Cargo, actually.)
*** Bash
#+NAME: prog_rust
#+begin_src shell :tangle my_settings_bash
if [ -d $HOME/.cargo ]; then
  printf "${check_symbol} Cargo directory detected at $HOME/.cargo\n"
  sleep ${line_delay}
  source $HOME/.cargo/env
fi
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<prog_rust>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
if test -d "$HOME/.cargo"
    printf "$check_symbol Cargo directory detected at $HOME/.cargo\n"
    sleep $line_delay
    addpath "$HOME/.cargo/bin"
end
#+end_src

** Homebrewed GCC
These are default gccs compiled by =../unix_dev_setup= script. They were implemented due to CUDA needing a bit old gcc. Especially, my MBP can only install CUDA 6.5 which relies on gcc 4.8 or less.

*** Bash
#+NAME: prog_homebrew_gcc
#+begin_src shell :tangle my_settings_bash
if [ -d $HOMEBREW/.opt/gcc-jit ]; then
  printf "${check_symbol} Gcc with libgccjit found in the system!\n"
  addpath "$HOMEBREW/.opt/gcc-jit/bin"
fi
if [ -d $HOMEBREW/.opt/gcc9 ]; then
  printf "${check_symbol} Gcc9 found in the system!\n"
  addpath "$HOMEBREW/.opt/gcc9/bin"
fi
if [ -d $HOMEBREW/.opt/gcc8 ]; then
  printf "${check_symbol} Gcc8 found in the system!\n"
  addpath "$HOMEBREW/.opt/gcc8/bin"
fi
if [ -d $HOMEBREW/.opt/gcc4 ]; then
  printf "${check_symbol} Gcc4 found in the system!\n"
  addpath "$HOMEBREW/.opt/gcc4/bin"
fi
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<prog_homebrew_gcc>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
if test -d "$HOMEBREW/.opt/gcc-jit"
    printf "$check_symbol Gcc with libgccjit found in the system!\n"
    addpath "$HOMEBREW/.opt/gcc-jit/bin"
end
if test -d "$HOMEBREW/.opt/gcc9"
    printf "$check_symbol Gcc9 found in the system!\n"
    addpath "$HOMEBREW/.opt/gcc9/bin"
end
if test -d "$HOMEBREW/.opt/gcc8"
    printf "$check_symbol Gcc8 found in the system!\n"
    addpath "$HOMEBREW/.opt/gcc8/bin"
end
if test -d "$HOMEBREW/.opt/gcc4"
    printf "$check_symbol Gcc4 found in the system!\n"
    addpath "$HOMEBREW/.opt/gcc4/bin"
end
#+end_src

** Golang
*** Bash
#+NAME: prog_golang
#+begin_src shell :tangle my_settings_bash
export GOROOT=$HOMEBREW/.opt/go
export GOPATH=$HOMEBREW/.opt/go/bin
if [ -d $GOROOT ]; then
  printf "${check_symbol} Golang has been found at $GOROOT\n"
  addpath "$GOPATH/bin:$GOPATH"
fi
#+end_src
*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<prog_golang>>
#+end_src
*** Fish
#+begin_src fish :tangle my_settings_fish
set GOROOT "$HOMEBREW/.opt/go"
set GOPATH "$HOMEBREW/.opt/go/bin"
if test -d "$GOROOT"
    printf "$check_symbol Golang has been found at $GOROOT\n"
    addpath "$GOPATH"
end
#+end_src

** Snapd stuff
*** Bash
#+NAME: prog_snapd
#+begin_src shell :tangle my_settings_bash
SNAP_BIN=/snap/bin
if [ -d "$SNAP_BIN" ]; then
	printf "${check_symbol} Snap executables have been found at $SNAP_BIN\n"
	addpath "$SNAP_BIN"
fi
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<prog_snapd>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
set SNAP_BIN /snap/bin
if test -d "$SNAP_BIN"
    printf "$check_symbol Snap executables have been found at $SNAP_BIN\n"
    addpath "$SNAP_BIN"
end
#+end_src

** VNC setup
*** Bash
#+NAME: prog_vnc
#+begin_src shell :tangle my_settings_bash
if [ -x "$(command -v vncserver)" ]; then
  echo "*** VNC server found! ***"
  echo " To start: vncstart"
  echo " To end: vnckill"
  echo ""
  alias vncstart="vncserver -localhost no -useold -geometry 1200x800 -depth 32"
  alias vnckill="vncserver -kill :1"
fi
#+end_src
*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<prog_vnc>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
if type -q vncserver
    echo "$check_symbol VNC server found!"
    echo "  To start: vncstart"
    echo "  To end: vnckill"
    alias vncstart="vncserver -localhost no -useold -geometry 1200x800 -depth 32"
    alias vnckill="vncserver -kill :1"
end
#+end_src

** Bpytop - top, htop, and bashtop replacement by Python3
*** Bash
#+NAME: prog_bashtop
#+begin_src shell :tangle my_settings_bash
if [ -x "$(command -v $HOMEBREW/bin/pip3)" ]; then
  if [ -x "$(command -v $HOMEBREW/bin/bpytop)" ]; then
    printf "${check_symbol} Locally installed bpytop found!\n"
    sleep ${line_delay}
    alias bpytop="$HOMEBREW/bin/pip3 install -U bpytop && bpytop"
    alias htop=bpytop
    alias top=bpytop
  fi
fi
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<prog_bashtop>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
if type -q $HOMEBREW/bin/pip3
    and type -q $HOMEBREW/bin/bpytop
    printf "$check_symbol Locally installed bpytop found!\n"
    sleep $line_delay
    alias bpytop="$HOMEBREW/bin/pip3 install -U bpytop; $HOMEBREW/bin/bpytop"
    alias htop="$HOMEBREW/bin/bpytop"
    alias top="$HOMEBREW/bin/bpytop"
end
#+end_src

** ROOT
*** Bash
#+NAME: prog_ROOT
#+begin_src shell :tangle my_settings_bash
ROOT_DIR=$HOMEBREW/.opt/ROOT
if [ -x "$(command -v $ROOT_DIR/bin/root)" ]; then
  printf "${check_symbol} ROOT Found! Applying its shell env.\n"
  alias thisroot="$ROOT_DIR/bin/thisroot.sh"
fi
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<prog_ROOT>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
set ROOT_DIR "$HOMEBREW/.opt/ROOT"
if type -q "$ROOT_DIR/bin/root"
    printf "$check_symbol ROOT Found! Applying its shell env.\n"
    alias thisroot="$ROOT_DIR/bin/thisroot.fish"
end
#+end_src

** Neovim
*** Bash
#+NAME: prog_neovim
#+begin_src shell :tangle my_settings_bash
if [ -x "$(command -v nvim)" ]; then
  printf "${check_symbol} Neovim found! replacing vim!\n"
  sleep ${line_delay}
  alias vim="nvim"
  alias vi="nvim"
fi
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<prog_neovim>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
if type -q nvim
    printf "$check_symbol Neovim found! replacing vim!\n"
    sleep $line_delay
    alias vim='nvim'
    alias vi='nvim'
end
#+end_src

** Texlive
*** Bash
#+NAME: prog_texlive
#+begin_src shell :tangle my_settings_bash
texlive_year="2020"
texlive_arch=x86_64-linux
texlive_bin_dir=$texlive_base_path/$texlive_year/bin/$texlive_arch/
texlive_bin_dir_woyear=$texlive_base_path/bin/$texlive_arch/
if [ -d $texlive_bin_dir ]; then
  printf "${check_symbol} Texlive found at $texlive_bin_dir directory!!\n"
  export PATH=$texlive_bin_dir:$PATH
elif [ -d $texlive_bin_dir_woyear ]; then
  printf "${check_symbol} Texlive found at $texlive_bin_dir_woyear directory!!\n"
  export PATH=$texlive_bin_dir_woyear:$PATH
fi
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<prog_texlive>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
set texlive_year "2020"
set texlive_arch "x86_64-linux"
set texlive_bin_dir "$texlive_base_path/$texlive_year/bin/$texlive_arch"
set texlive_bin_dir_woyear "$texlive_base_path/bin/$texlive_arch"
if test -d "$texlive_bin_dir"
    printf "$check_symbol Texlive found at $texlive_bin_dir directory!!\n"
    addpath "$texlive_bin_dir"
else if test -d "$texlive_bin_dir_woyear"
    printf "$check_symbol Texlive found at $texlive_bin_dir_woyear directory!!\n"
    addpath "$texlive_bin_dir_woyear"
end
#+end_src

** PyPy - Homebrewed pypy3
*** Bash
#+NAME: prog_pypy
#+begin_src shell :tangle my_settings_bash
if [ -x "$(command -v $HOMEBREW/.opt/pypy/bin/pypy3)" ]; then
  printf "${check_symbol} pypy3 found in $HOMEBREW/.opt/pypy/bin/pypy3!!\n"
  sleep ${line_delay}
  export PATH=$HOMEBREW/.opt/pypy/bin:$PATH
fi
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<prog_pypy>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
if type -q "$HOMEBREW/.opt/pypy/bin/pypy3"
    printf "$check_symbol pypy3 found in $HOMEBREW/.oopt/pypy/bin/pypy3"
    sleep $line_delay
    addpath "$HOMEBREW/.opt/pypy/bin"
end
#+end_src

** n - Homebrewed Node.JS's update tool
*** Bash
#+NAME: prog_n
#+begin_src shell :tangle my_settings_bash
if [ -x "$(command -v n)" ]; then
  printf "${check_symbol} n found!, Setting up N_PREFIX environment variable.\n"
  sleep ${line_delay}
  export N_PREFIX=$(command -v n | sed -E 's/\/bin\/n//')
fi
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<prog_n>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
if type -q n
    printf "$check_symbol n found!, Setting up N_PREFIX for it!\n"
    sleep $line_delay
    set -U N_PREFIX (type -p n | sed -E 's/\/bin\/n//g')
end
#+end_src

** IrfanView - What? yeah, wine!
*** Bash
#+NAME: prog_irfanview
#+begin_src shell :tangle my_settings_bash
iview64_path=$HOME/.wine/drive_c/Program\ Files/IrfanView/i_view64.exe
run_iview ()
{
  wine "$iview64_path" `winepath --windows $@`
}
if [ -x "$(command -v wine)" ]; then
  if [ -f "$iview64_path" ]; then
    printf "${check_symbol} Irfanview found!!\n"
    printf "  ${right_arrow_symbol} Usage: iview <files>\n"
    alias iview=run_iview
    sleep ${line_delay}
  fi
fi
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<prog_irfanview>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
set iview64_path "$HOME/.wine/drive_c/Program\ Files/IrfanView/i_view64.exe"
function run_iview
    wine "$iview64_path" (winepath --windows $argv[@])
end
if type -q wine
    and test -f "$iview64_path"
    printf "$check_symbol Irfanveiw found!\n"
    printf "  $right_arrow_symbol Usage: iview <files>\n"
    alias iview='run_iview'
    sleep $line_dealy
end
#+end_src

** Doomemacs! DOOM! and EVIL!
*** Bash
#+NAME: prog_doomemacs
#+begin_src shell :tangle my_settings_bash
if [ -x "$HOME/.emacs.d/bin/doom" ] && [ -d "$HOME/.doom.d" ]; then
  printf "${check_symbol} Doomemacs found! Adding to path!\n"
  addpath "$HOME/.emacs.d/bin"
fi
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<prog_doomemacs>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
if test -d "$HOME/.emacs.d/bin"
    and test -d "$HOME/.doom.d"
    printf "$check_symbol Doomemacs found! Adding to path!\n"
    addpath "$HOME/.emacs.d/bin"
end
#+end_src

** Cuda for NVIDIA 9600/9400m
*** Bash
#+NAME: prog_cuda_old
#+begin_src shell :tangle my_settings_bash
if [ -d "/usr/local/cuda-6.5" ]; then
  printf "${check_symbol} CUDA 6.5 found! Doing some env stuff for it.\n"
  export LD_LIBRARY_PATH="/usr/local/cuda-6.5/lib64":$LD_LIBRARY_PATH
  export PATH=$PATH:"/usr/local/cuda-6.5/bin"
fi
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<prog_cuda_old>>
#+end_src

*** Fish
#+begin_src fish :my_settings_fish
if test -d "/usr/local/cuda-6.5"
    printf "$check_symbol CUDA 6.5 found! Doing some env stuff for it.\n"
    set -Ua LD_LIBRARY_PATH "/usr/local/cuda-6.5/lib64"
    set -Up fish_user_paths "/usr/local/cuda-6.5/bin"
end
#+end_src

** Geolocation
*** Bash
#+NAME: prog_jq
#+begin_src shell :tangle my_settings_bash
if [ -x "$(command -v jq)" ]; then
	echo "${check_symbol} jq found, we can use geolocation alias as: geoloc"
	alias geoloc="curl -s https://ipvigilante.com/$(curl -s https://ipinfo.io/ip) | jq '.data.latitude, .data.longitude, .data.city_name, .data.country_name'"
fi
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<prog_jq>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
if type -q jq
    echo "$check_symbol jq found, we can use geolocation alias as: geoloc"
    alias geoloc="curl -s https://ipvigilante.com/(curl -s https://ipinfo.io/ip) | jq '.data.latitude, .data.longitude, .data.city_name, .data.country_name'"
end
#+end_src


* Rust replacements

** Du-dust - du replacement
*** Bash
#+NAME: prog_dust
#+begin_src shell :tangle my_settings_bash
if [ -x "$(command -v dust)" ]; then
	printf "${check_symbol} dust found! Using it instead of du!\n"
	alias du='dust -r'
else
	alias du='du -skh | sort -r'
fi
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<prog_dust>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
if type -q dust
    printf "$check_symbol dust found! Using it instead of du!\n"
    alias du='dust -r'
else
    alias du='du -skh | sort -r'
end
#+end_src

** Bat - cat replacement
*** Bash
#+NAME: prog_bat
#+begin_src shell :tangle my_settings_bash
if [ -x "$(command -v bat)" ]; then
  printf "${check_symbol} bat found! using it instead of cat\n"
  sleep ${line_delay}
  alias cat='bat'
fi
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<prog_bat>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
if type -q bat
    printf "$check_symbol bat found! using it instead of cat\n"
    sleep $line_delay
    alias cat='bat'
end
#+end_src

** Rip - rm-improved
*** Bash
#+NAME: prog_rip
#+begin_src shell :tangle my_settings_bash
trash_location="$HOME/.local/share/Trash/files/"
if [ -x "$(command -v rip)" ]; then
  printf "${check_symbol} rip, rm-improved found!\n  ${right_arrow_symbol} Setting up graveyard at $trash_location\n"
  sleep ${line_delay}
  alias rip="rip --graveyard $trash_location"
fi
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<prog_rip>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
set trash_location "$HOME/.local/share/Trash/files/"
if type -q rip
    printf "$check_symbol rip, rm-improved found!\n  $right_arrow_symbol Setting up graveyard at $trash_location\n"
    sleep $line_delay
    alias rip="rip --graveyard $trash_location"
end
#+end_src

** Zoxide - z replacement
*** Bash
#+NAME: prog_zoxide
#+begin_src shell :tangle my_settings_bash
if [ -x "$(command -v zoxide)" ]; then
  printf "${check_symbol} zoxide found! activating it!\n"
  sleep ${line_delay}
  if [[ "$(echo $0)" == *bash ]]; then
    eval "$(zoxide init bash)"
  elif [[ "$(echo $0)" == *zsh ]]; then
    eval "$(zoxide init zsh)"
  else
    eval "$(zoxide init posix --hook prompt)"
  fi
  alias cd='z'
fi
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<prog_zoxide>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
if type -q zoxide
    printf "$check_symbol zoxide found! activating it! (z replaces cd)\n"
    sleep $line_delay
    zoxide init fish | source
    # On fish, cd has an alias! So, using yet another alias to alias is not a good idea!
    # Just use z instead of cd
    # alias cd='z'
end
#+end_src

* Mount Clouds
** Google Drive
*** Bash
#+NAME: mount_google_drive
#+begin_src shell :tangle my_settings_bash
if [ -x "$(command -v rclone)" ]; then

	if [ ! -d $GOOGLE_DRIVE ]; then
		printf "${check_symbol} Google drive mount point not found! making one..\n"
		mkdir -pv $GOOGLE_DRIVE
	fi

	if grep -qs $GOOGLE_DRIVE /proc/mounts; then
		printf "${check_symbol} Google Drive already mounted at $GOOGLE_DRIVE\n"
		sleep ${line_delay}
	elif [ ! -f "$HOME/.config/rclone/rclone.conf" ]; then
		printf "${check_symbol} RClone was for Google drive not set up yet!\n"
	else
		if [ ! -z "$(cat $HOME/.config/rclone/rclone.conf | grep "\[google-drive\]")" ]; then
			printf "${check_symbol} Mounting Google Drive to $GOOGLE_DRIVE\n"
			rclone mount google-drive: $GOOGLE_DRIVE &
			sleep 2

		fi
	fi
fi
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_bash :noweb yes
<<mount_google_drive>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
if type -q rclone
    if not test -d "$GOOGLE_DRIVE"
        printf "$check_symbol Google drive mount point not found! making one...\n"
        mkdir -pv "$GOOGLE_DRIVE"
    end

    if grep -qs "$GOOGLE_DRIVE" /proc/mounts
        printf "$check_symbol Google drive already mounted at $GOOGLE_DRIVE\n"
        sleep $line_delay
    else if not test -f "$HOME/.config/rclone/rclone.conf"
        printf "$check_symbol RClone for Google drive has not set yet!\n"
    else
        if test -n (cat $HOME/.config/rclone/rclone.conf | grep "\[google-drive\]")
            printf "$check_symbol Mounting Google Drive to $GOOGLE_DRIVE\n"
            rclone mount google-drive: "$GOOGLE_DRIVE" &
            sleep 2
        end
    end
end
#+end_src

** Onedrive
*** Bash
#+NAME: cloud_onedrive
#+begin_src shell :tangle my_settings_bash
if [ -x "$(command -v rclone)" ]; then
	if grep -qs $ONE_DRIVE /proc/mounts; then
		printf "${check_symbol} MS One Drive already mounted at $ONE_DRIVE\n"
		sleep ${line_delay}
	elif [ ! -f "$HOME/.config/rclone/rclone.conf" ]; then
		printf "${check_symbol} RClone for Onedrive was not set up yet!\n"
	else
		if [ ! -z "$(cat $HOME/.config/rclone/rclone.conf | grep "\[onedrive\]")" ]; then
			printf "${check_symbol} Mounting MS One Drive to $ONE_DRIVE\n"
			rclone mount --vfs-cache-mode writes onedrive: $ONE_DRIVE &
			sleep 2

		fi
	fi
fi
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<cloud_onedrive>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
if type -q rclone
    if not test -d "$ONE_DRIVE"
        printf "$check_symbol MS One Drive mount point not found! making one...\n"
        mkdir -pv "$ONE_DRIVE"
    end

    if grep -qs "$ONE_DRIVE" /proc/mounts
        printf "$check_symbol MS One drive already mounted at $ONE_DRIVE\n"
        sleep $line_delay
    else if not test -f "$HOME/.config/rclone/rclone.conf"
        printf "$check_symbol RClone for Onedrive has not set yet!\n"
    else
        if test -n (cat $HOME/.config/rclone/rclone.conf | grep "\[onedrive\]")
            printf "$check_symbol Mounting MS One Drive to $ONE_DRIVE\n"
            rclone mount --vfs-cache-mode writes onedrive: $ONE_DRIVE &
            sleep 2
        end
    end
end
#+end_src


* Shell extension
** Starship
*** Bash
#+NAME: shellext_starship
#+begin_src shell :tangle my_settings_bash
if [ -x "$(command -v starship)" ]; then
  printf "${check_symbol} Starship shell extension found! Let's start it!\n"
  sleep ${line_delay}
  printf "  ${right_arrow_symbol} Running it as zsh"
  eval "$(starship init zsh)"
fi
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<shellext_starship>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
if type -q starship
    printf "$check_symbol Starship shell extension found! Let's start it!\n"
    sleep $line_delay
    starship init fish | source
end
#+end_src

* Final start-up
** Clear screen
*** Bash
#+NAME: autobat_clear
#+begin_src shell :tangle my_settings_bash
clear
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<autobat_clear>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish :noweb yes
<<autobat_clear>>
#+end_src

** Run Neofetch
*** Bash
#+NAME: autobat_neofetch
#+begin_src shell :tangle my_settings_bash
if [ -x "$(command -v neofetch)" ] && [ $(printf '%.0f' $(check_uptime)) -lt 2400 ]; then
	neofetch
fi
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<autobat_neofetch>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
if type -q neofetch
    and test (printf '%.0f' (check_uptime)) -lt 2400
    neofetch
end
#+end_src

** Clean up path
*** Bash
#+NAME: autobat_path_cleaup
#+begin_src shell :tangle my_settings_bash
export PATH=$(printf "%s" "$PATH" | awk -v RS=':' '!a[$1]++ { if (NR > 1) printf RS; printf $1 }')
#+end_src

*** Zsh
#+begin_src shell :tangle my_settings_zsh :noweb yes
<<autobat_path_cleaup>>
#+end_src

*** Fish
#+begin_src fish :tangle my_settings_fish
# Fish don't need this...
#+end_src
